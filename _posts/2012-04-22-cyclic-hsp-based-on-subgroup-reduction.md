---
layout: post
title: "Cyclic HSP based on Subgroup Reduction"
tags: maths cs
---

{% raw %}

  
<div id="p1" class="ltx_para">
<p class="ltx_p">In my <a href="/computer-science/master-thesis/">master thesis</a>
on quantum computing, I designed a version of the Abelian HSP algorithm based
on subgroup reduction. In
<a href="/two-open-problems-for-the-subgroup-reduction-based-dedekindian-hsp-algorithm.html">this blog post</a>, I wondered whether this algorithm could be extended to the
Dedekindian HSP and if it would be more efficient than the standard one. I’m
going to prove that the latter is false in the cyclic case, where the two
algorithms have exactly the same associated Markov chain.</p>
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p">Recall that the HSP is - given a finite group <math id="p2.m1" class="ltx_Math" alttext="G" display="inline"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>, an unknown subgroup <math id="p2.m2" class="ltx_Math" alttext="H" display="inline"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math> and
an "oracle" <math id="p2.m3" class="ltx_Math" alttext="f" display="inline"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> hiding <math id="p2.m4" class="ltx_Math" alttext="H" display="inline"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math> (i.e. a function on <math id="p2.m5" class="ltx_Math" alttext="G" display="inline"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> which factorizes on the
coset space <math id="p2.m6" class="ltx_Math" alttext="G/H" display="inline"><semantics><mrow><mi>G</mi><mo>/</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">G/H</annotation></semantics></math> in a function with pairwise distinct values) - to determine
the subgroup <math id="p2.m7" class="ltx_Math" alttext="H" display="inline"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math> using a number of oracle calls polynomial in the size of <math id="p2.m8" class="ltx_Math" alttext="G" display="inline"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>.</p>
</div>
<div id="p3" class="ltx_para">
<p class="ltx_p">In the standard Dedekindian HSP algorithm, <math id="p3.m1" class="ltx_Math" alttext="G" display="inline"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> is a
<a href="http://en.wikipedia.org/wiki/Hamiltonian_group" title="" class="ltx_ref">dedekindian group</a>
and we use Fourier Sampling to measure a polynomial number of representations
<math id="p3.m2" class="ltx_Math" alttext="\rho_{1},...\rho_{m}" display="inline"><semantics><mrow><msub><mi>ρ</mi><mn>1</mn></msub><mo>,</mo><mrow><mi mathvariant="normal">…</mi><mo>⁢</mo><msub><mi>ρ</mi><mi>m</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\rho_{1},...\rho_{m}</annotation></semantics></math> of <math id="p3.m3" class="ltx_Math" alttext="G" display="inline"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> such that <math id="p3.m4" class="ltx_Math" alttext="H\subseteq\operatorname{Ker}{\rho_{k}}" display="inline"><semantics><mrow><mi>H</mi><mo>⊆</mo><mrow><mo>Ker</mo><mo>⁡</mo><msub><mi>ρ</mi><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">H\subseteq\operatorname{Ker}{\rho_{k}}</annotation></semantics></math>. One proves
that with high probability <math id="p3.m5" class="ltx_Math" alttext="H=\cap_{k}\operatorname{Ker}{\rho_{k}}" display="inline"><semantics><mrow><mi>H</mi><mo>=</mo><mrow><msub><mo>∩</mo><mi>k</mi></msub><mrow><mo>Ker</mo><mo>⁡</mo><msub><mi>ρ</mi><mi>k</mi></msub></mrow></mrow></mrow><annotation encoding="application/x-tex">H=\cap_{k}\operatorname{Ker}{\rho_{k}}</annotation></semantics></math>.
In my alternative algorithm, we measure
<math id="p3.m6" class="ltx_Math" alttext="\rho_{1}" display="inline"><semantics><msub><mi>ρ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\rho_{1}</annotation></semantics></math> and set <math id="p3.m7" class="ltx_Math" alttext="G_{1}=\operatorname{Ker}{\rho_{1}}" display="inline"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo>=</mo><mrow><mo>Ker</mo><mo>⁡</mo><msub><mi>ρ</mi><mn>1</mn></msub></mrow></mrow><annotation encoding="application/x-tex">G_{1}=\operatorname{Ker}{\rho_{1}}</annotation></semantics></math>. Then instead of continuing to work on
the whole group <math id="p3.m8" class="ltx_Math" alttext="G" display="inline"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>, the idea is to move to a HSP
problem on <math id="p3.m9" class="ltx_Math" alttext="G_{1}" display="inline"><semantics><msub><mi>G</mi><mn>1</mn></msub><annotation encoding="application/x-tex">G_{1}</annotation></semantics></math> with hidden subgroup <math id="p3.m10" class="ltx_Math" alttext="H" display="inline"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>. Then do a Fourier Sampling on <math id="p3.m11" class="ltx_Math" alttext="G_{1}" display="inline"><semantics><msub><mi>G</mi><mn>1</mn></msub><annotation encoding="application/x-tex">G_{1}</annotation></semantics></math>
to move to a new subgroup <math id="p3.m12" class="ltx_Math" alttext="G_{2}" display="inline"><semantics><msub><mi>G</mi><mn>2</mn></msub><annotation encoding="application/x-tex">G_{2}</annotation></semantics></math> and so forth. If <math id="p3.m13" class="ltx_Math" alttext="H\subsetneq G_{k}" display="inline"><semantics><mrow><mi>H</mi><mo>⊊</mo><msub><mi>G</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">H\subsetneq G_{k}</annotation></semantics></math> then
there is a probability at least one half, that <math id="p3.m14" class="ltx_Math" alttext="G_{k+1}" display="inline"><semantics><msub><mi>G</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">G_{k+1}</annotation></semantics></math> is at least twice
smaller and so we see that we reach <math id="p3.m15" class="ltx_Math" alttext="H" display="inline"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math> in an exponentially fast way.</p>
</div>
<div id="p4" class="ltx_para">
<p class="ltx_p">Let’s now consider the cyclic HSP. We are given a cyclic group
<math id="p4.m1" class="ltx_Math" alttext="G=\mathbb{Z}_{N}=\mathbb{Z}/{N\mathbb{Z}}" display="inline"><semantics><mrow><mi>G</mi><mo>=</mo><msub><mi>ℤ</mi><mi>N</mi></msub><mo>=</mo><mrow><mrow><mi>ℤ</mi><mo>/</mo><mi>N</mi></mrow><mo>⁢</mo><mi>ℤ</mi></mrow></mrow><annotation encoding="application/x-tex">G=\mathbb{Z}_{N}=\mathbb{Z}/{N\mathbb{Z}}</annotation></semantics></math> and a hidden subgroup <math id="p4.m2" class="ltx_Math" alttext="H=d\mathbb{Z}_{N}" display="inline"><semantics><mrow><mi>H</mi><mo>=</mo><mrow><mi>d</mi><mo>⁢</mo><msub><mi>ℤ</mi><mi>N</mi></msub></mrow></mrow><annotation encoding="application/x-tex">H=d\mathbb{Z}_{N}</annotation></semantics></math> for
some <math id="p4.m3" class="ltx_Math" alttext="1\leq d\leq N" display="inline"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>d</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1\leq d\leq N</annotation></semantics></math> (we exclude the case <math id="p4.m4" class="ltx_Math" alttext="H=0" display="inline"><semantics><mrow><mi>H</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H=0</annotation></semantics></math>, which is easy) and an
oracle <math id="p4.m5" class="ltx_Math" alttext="f" display="inline"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>. With this setting, one call to <math id="p4.m6" class="ltx_Math" alttext="f" display="inline"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> allows to get a
Fourier sample <math id="p4.m7" class="ltx_Math" alttext="\lambda\frac{N}{d}" display="inline"><semantics><mrow><mi>λ</mi><mo>⁢</mo><mfrac><mi>N</mi><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\lambda\frac{N}{d}</annotation></semantics></math> for some random
<math id="p4.m8" class="ltx_Math" alttext="\lambda\in\{0,1,...,d-1\}" display="inline"><semantics><mrow><mi>λ</mi><mo>∈</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda\in\{0,1,...,d-1\}</annotation></semantics></math>, with uniform probability. In the standard
cyclic HSP, we repeat Fourier sampling to get
<math id="p4.m9" class="ltx_Math" alttext="\lambda_{1}\frac{N}{d},\lambda_{2}\frac{N}{d},...\lambda_{m}\frac{N}{d}" display="inline"><semantics><mrow><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo>⁢</mo><mfrac><mi>N</mi><mi>d</mi></mfrac></mrow><mo>,</mo><mrow><msub><mi>λ</mi><mn>2</mn></msub><mo>⁢</mo><mfrac><mi>N</mi><mi>d</mi></mfrac></mrow><mo>,</mo><mrow><mi mathvariant="normal">…</mi><mo>⁢</mo><msub><mi>λ</mi><mi>m</mi></msub><mo>⁢</mo><mfrac><mi>N</mi><mi>d</mi></mfrac></mrow></mrow><annotation encoding="application/x-tex">\lambda_{1}\frac{N}{d},\lambda_{2}\frac{N}{d},...\lambda_{m}\frac{N}{d}</annotation></semantics></math>
and deduce <math id="p4.m10" class="ltx_Math" alttext="d" display="inline"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>. For example, one can show that</p>
</div>
<div id="p5" class="ltx_para">
<table id="S0.Ex1" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex1.m1" class="ltx_Math" alttext="P(\frac{N}{\gcd{\left(\lambda_{k}\frac{N}{d}\right)}_{1\leq k\leq m}}=d)\geq 1%
-2^{-m/2}" display="block"><semantics><mrow><mi>P</mi><mrow><mo stretchy="false">(</mo><mfrac><mi>N</mi><mrow><mi>gcd</mi><msub><mrow><mo>(</mo><msub><mi>λ</mi><mi>k</mi></msub><mfrac><mi>N</mi><mi>d</mi></mfrac><mo>)</mo></mrow><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow></msub></mrow></mfrac><mo>=</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><mo>≥</mo><mn>1</mn><mo>-</mo><msup><mn>2</mn><mrow><mo>-</mo><mrow><mi>m</mi><mo>/</mo><mn>2</mn></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">P(\frac{N}{\gcd{\left(\lambda_{k}\frac{N}{d}\right)}_{1\leq k\leq m}}=d)\geq 1%
-2^{-m/2}</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="p6" class="ltx_para">
<p class="ltx_p">In the algorithm I proposed, we build a sequence of polynomial length
<math id="p6.m1" class="ltx_Math" alttext="H\subseteq G_{m}\subseteq G_{m-1}\subseteq...\subseteq G_{1}=G=\mathbb{Z}_{N}" display="inline"><semantics><mrow><mi>H</mi><mo>⊆</mo><msub><mi>G</mi><mi>m</mi></msub><mo>⊆</mo><msub><mi>G</mi><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>⊆</mo><mi mathvariant="normal">…</mi><mo>⊆</mo><msub><mi>G</mi><mn>1</mn></msub><mo>=</mo><mi>G</mi><mo>=</mo><msub><mi>ℤ</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">H\subseteq G_{m}\subseteq G_{m-1}\subseteq...\subseteq G_{1}=G=\mathbb{Z}_{N}</annotation></semantics></math>
such that with high probability, <math id="p6.m2" class="ltx_Math" alttext="H=G_{m}" display="inline"><semantics><mrow><mi>H</mi><mo>=</mo><msub><mi>G</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">H=G_{m}</annotation></semantics></math>. Clearly, all the <math id="p6.m3" class="ltx_Math" alttext="G_{k}" display="inline"><semantics><msub><mi>G</mi><mi>k</mi></msub><annotation encoding="application/x-tex">G_{k}</annotation></semantics></math>’s are
cyclic groups and can be written <math id="p6.m4" class="ltx_Math" alttext="G_{k}=a_{k}\mathbb{Z}_{N}" display="inline"><semantics><mrow><msub><mi>G</mi><mi>k</mi></msub><mo>=</mo><mrow><msub><mi>a</mi><mi>k</mi></msub><mo>⁢</mo><msub><mi>ℤ</mi><mi>N</mi></msub></mrow></mrow><annotation encoding="application/x-tex">G_{k}=a_{k}\mathbb{Z}_{N}</annotation></semantics></math>. Since they contain
<math id="p6.m5" class="ltx_Math" alttext="H=d\mathbb{Z}_{N}" display="inline"><semantics><mrow><mi>H</mi><mo>=</mo><mrow><mi>d</mi><mo>⁢</mo><msub><mi>ℤ</mi><mi>N</mi></msub></mrow></mrow><annotation encoding="application/x-tex">H=d\mathbb{Z}_{N}</annotation></semantics></math>, we have <math id="p6.m6" class="ltx_Math" alttext="a_{k}|d" display="inline"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><mo stretchy="false">|</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a_{k}|d</annotation></semantics></math>. From <math id="p6.m7" class="ltx_Math" alttext="a_{k}" display="inline"><semantics><msub><mi>a</mi><mi>k</mi></msub><annotation encoding="application/x-tex">a_{k}</annotation></semantics></math>, we set <math id="p6.m8" class="ltx_Math" alttext="d_{k}=\frac{d}{a}_{k}" display="inline"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><msub><mfrac><mi>d</mi><mi>a</mi></mfrac><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_{k}=\frac{d}{a}_{k}</annotation></semantics></math>
and <math id="p6.m9" class="ltx_Math" alttext="N_{k}=\frac{N}{a}_{k}" display="inline"><semantics><mrow><msub><mi>N</mi><mi>k</mi></msub><mo>=</mo><msub><mfrac><mi>N</mi><mi>a</mi></mfrac><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">N_{k}=\frac{N}{a}_{k}</annotation></semantics></math>. We have the isomorphism
<math id="p6.m10" class="ltx_Math" alttext="\phi_{k}:G_{k}\overset{\sim}{\to}\mathbb{Z}_{N_{k}}" display="inline"><semantics><mrow><msub><mi>ϕ</mi><mi>k</mi></msub><mo>:</mo><mrow><msub><mi>G</mi><mi>k</mi></msub><mo>⁢</mo><mover accent="true"><mo>→</mo><mo>∼</mo></mover><mo>⁢</mo><msub><mi>ℤ</mi><msub><mi>N</mi><mi>k</mi></msub></msub></mrow></mrow><annotation encoding="application/x-tex">\phi_{k}:G_{k}\overset{\sim}{\to}\mathbb{Z}_{N_{k}}</annotation></semantics></math> defined by <math id="p6.m11" class="ltx_Math" alttext="\phi_{k}(x)=\frac{x}{a}_{k}" display="inline"><semantics><mrow><mrow><msub><mi>ϕ</mi><mi>k</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msub><mfrac><mi>x</mi><mi>a</mi></mfrac><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\phi_{k}(x)=\frac{x}{a}_{k}</annotation></semantics></math>.
Hence we can now work on <math id="p6.m12" class="ltx_Math" alttext="\mathbb{Z}_{N_{k}}" display="inline"><semantics><msub><mi>ℤ</mi><msub><mi>N</mi><mi>k</mi></msub></msub><annotation encoding="application/x-tex">\mathbb{Z}_{N_{k}}</annotation></semantics></math>, with a hidden subgroup
<math id="p6.m13" class="ltx_Math" alttext="H_{k}=\phi_{k}(H)=d_{k}\mathbb{Z}_{N_{k}}" display="inline"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub><mo>=</mo><mrow><msub><mi>ϕ</mi><mi>k</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>⁢</mo><msub><mi>ℤ</mi><msub><mi>N</mi><mi>k</mi></msub></msub></mrow></mrow><annotation encoding="application/x-tex">H_{k}=\phi_{k}(H)=d_{k}\mathbb{Z}_{N_{k}}</annotation></semantics></math> and oracle <math id="p6.m14" class="ltx_Math" alttext="f_{k}=f\circ\phi_{k}^{-1}" display="inline"><semantics><mrow><msub><mi>f</mi><mi>k</mi></msub><mo>=</mo><mrow><mi>f</mi><mo>∘</mo><msubsup><mi>ϕ</mi><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></mrow><annotation encoding="application/x-tex">f_{k}=f\circ\phi_{k}^{-1}</annotation></semantics></math>.</p>
</div>
<div id="p7" class="ltx_para">
<p class="ltx_p">We start with <math id="p7.m1" class="ltx_Math" alttext="G_{1}=G=\mathbb{Z}_{N},H_{1}=H=d\mathbb{Z}_{N},a_{1}=1,d_{1}=d,N_{1}=N" display="inline"><semantics><mrow><mrow><msub><mi>G</mi><mn>1</mn></msub><mo>=</mo><mi>G</mi><mo>=</mo><msub><mi>ℤ</mi><mi>N</mi></msub></mrow><mo>,</mo><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>=</mo><mi>H</mi><mo>=</mo><mrow><mi>d</mi><mo>⁢</mo><msub><mi>ℤ</mi><mi>N</mi></msub></mrow></mrow><mo>,</mo><mrow><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><mo>,</mo><mrow><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mi>d</mi></mrow><mo>,</mo><mrow><msub><mi>N</mi><mn>1</mn></msub><mo>=</mo><mi>N</mi></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">G_{1}=G=\mathbb{Z}_{N},H_{1}=H=d\mathbb{Z}_{N},a_{1}=1,d_{1}=d,N_{1}=N</annotation></semantics></math>.
At step <math id="p7.m2" class="ltx_Math" alttext="k" display="inline"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>, we perform a Fourier sampling that provides a random
<math id="p7.m3" class="ltx_Math" alttext="\lambda_{k}\frac{N_{k}}{d_{k}}" display="inline"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>⁢</mo><mfrac><msub><mi>N</mi><mi>k</mi></msub><msub><mi>d</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\lambda_{k}\frac{N_{k}}{d_{k}}</annotation></semantics></math> for some <math id="p7.m4" class="ltx_Math" alttext="\lambda_{k}\in\{0,1,...,d_{k}-1\}" display="inline"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>∈</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_{k}\in\{0,1,...,d_{k}-1\}</annotation></semantics></math>. Then,
applying the Continued Fraction Algorithm on
<math id="p7.m5" class="ltx_Math" alttext="\lambda_{k}\frac{N_{k}}{d_{k}}\frac{a_{k}}{N}=\frac{\lambda_{k}}{d_{k}}" display="inline"><semantics><mrow><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>⁢</mo><mfrac><msub><mi>N</mi><mi>k</mi></msub><msub><mi>d</mi><mi>k</mi></msub></mfrac><mo>⁢</mo><mfrac><msub><mi>a</mi><mi>k</mi></msub><mi>N</mi></mfrac></mrow><mo>=</mo><mfrac><msub><mi>λ</mi><mi>k</mi></msub><msub><mi>d</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\lambda_{k}\frac{N_{k}}{d_{k}}\frac{a_{k}}{N}=\frac{\lambda_{k}}{d_{k}}</annotation></semantics></math> we get an
irreducible fraction <math id="p7.m6" class="ltx_Math" alttext="\frac{p_{k}}{q_{k}}" display="inline"><semantics><mfrac><msub><mi>p</mi><mi>k</mi></msub><msub><mi>q</mi><mi>k</mi></msub></mfrac><annotation encoding="application/x-tex">\frac{p_{k}}{q_{k}}</annotation></semantics></math> and a divisor <math id="p7.m7" class="ltx_Math" alttext="q_{k}" display="inline"><semantics><msub><mi>q</mi><mi>k</mi></msub><annotation encoding="application/x-tex">q_{k}</annotation></semantics></math> of <math id="p7.m8" class="ltx_Math" alttext="d_{k}" display="inline"><semantics><msub><mi>d</mi><mi>k</mi></msub><annotation encoding="application/x-tex">d_{k}</annotation></semantics></math>. Set
<math id="p7.m9" class="ltx_Math" alttext="a_{k+1}=q_{k}a_{k}" display="inline"><semantics><mrow><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><msub><mi>q</mi><mi>k</mi></msub><mo>⁢</mo><msub><mi>a</mi><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">a_{k+1}=q_{k}a_{k}</annotation></semantics></math>. Then <math id="p7.m10" class="ltx_Math" alttext="G_{k+1}=a_{k+1}\mathbb{Z}_{N}" display="inline"><semantics><mrow><msub><mi>G</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>⁢</mo><msub><mi>ℤ</mi><mi>N</mi></msub></mrow></mrow><annotation encoding="application/x-tex">G_{k+1}=a_{k+1}\mathbb{Z}_{N}</annotation></semantics></math>
is a subgroup of <math id="p7.m11" class="ltx_Math" alttext="G_{k}" display="inline"><semantics><msub><mi>G</mi><mi>k</mi></msub><annotation encoding="application/x-tex">G_{k}</annotation></semantics></math>. Because <math id="p7.m12" class="ltx_Math" alttext="q_{k}|d_{k}" display="inline"><semantics><mrow><msub><mi>q</mi><mi>k</mi></msub><mo stretchy="false">|</mo><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">q_{k}|d_{k}</annotation></semantics></math>, we have
<math id="p7.m13" class="ltx_Math" alttext="{a_{k}q_{k}}|{a_{k}d_{k}}=d" display="inline"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><msub><mi>q</mi><mi>k</mi></msub><mo stretchy="false">|</mo><msub><mi>a</mi><mi>k</mi></msub><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">{a_{k}q_{k}}|{a_{k}d_{k}}=d</annotation></semantics></math> and so <math id="p7.m14" class="ltx_Math" alttext="H" display="inline"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math> is a subgroup of <math id="p7.m15" class="ltx_Math" alttext="G_{k+1}" display="inline"><semantics><msub><mi>G</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">G_{k+1}</annotation></semantics></math>.</p>
</div>
<div id="p8" class="ltx_para">
<p class="ltx_p">The general remark about the algorithm being exponentially fast is easy to
see in the cyclic case. Indeed if <math id="p8.m1" class="ltx_Math" alttext="q_{k}=1" display="inline"><semantics><mrow><msub><mi>q</mi><mi>k</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q_{k}=1</annotation></semantics></math> above, then <math id="p8.m2" class="ltx_Math" alttext="\lambda_{k}=p_{k}d_{k}" display="inline"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>=</mo><mrow><msub><mi>p</mi><mi>k</mi></msub><mo>⁢</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\lambda_{k}=p_{k}d_{k}</annotation></semantics></math>
which happens only if <math id="p8.m3" class="ltx_Math" alttext="\lambda_{k}=0" display="inline"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_{k}=0</annotation></semantics></math>. If at step <math id="p8.m4" class="ltx_Math" alttext="k" display="inline"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>, we have
<math id="p8.m5" class="ltx_Math" alttext="H\subsetneq G_{k}" display="inline"><semantics><mrow><mi>H</mi><mo>⊊</mo><msub><mi>G</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">H\subsetneq G_{k}</annotation></semantics></math> then <math id="p8.m6" class="ltx_Math" alttext="\lambda_{k}" display="inline"><semantics><msub><mi>λ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\lambda_{k}</annotation></semantics></math> can take a non-zero value with
probability at least one half. In that case <math id="p8.m7" class="ltx_Math" alttext="q_{k}\geq 2" display="inline"><semantics><mrow><msub><mi>q</mi><mi>k</mi></msub><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">q_{k}\geq 2</annotation></semantics></math> and
<math id="p8.m8" class="ltx_Math" alttext="a_{k+1}\geq 2a_{k}" display="inline"><semantics><mrow><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>≥</mo><mrow><mn>2</mn><mo>⁢</mo><msub><mi>a</mi><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">a_{k+1}\geq 2a_{k}</annotation></semantics></math>. Hence <math id="p8.m9" class="ltx_Math" alttext="a_{k}" display="inline"><semantics><msub><mi>a</mi><mi>k</mi></msub><annotation encoding="application/x-tex">a_{k}</annotation></semantics></math> grows exponentially fast until it becomes
stationary and thus <math id="p8.m10" class="ltx_Math" alttext="a_{m}=d" display="inline"><semantics><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a_{m}=d</annotation></semantics></math> with very high probability.</p>
</div>
<div id="p9" class="ltx_para">
<p class="ltx_p">We can prove that we get the same procedure using only Fourier sampling on the
initial group <math id="p9.m1" class="ltx_Math" alttext="G" display="inline"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>. Suppose we have measured Fourier samples
<math id="p9.m2" class="ltx_Math" alttext="\lambda_{1}\frac{N}{d},\lambda_{2}\frac{N}{d},...\lambda_{m}\frac{N}{d}" display="inline"><semantics><mrow><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo>⁢</mo><mfrac><mi>N</mi><mi>d</mi></mfrac></mrow><mo>,</mo><mrow><msub><mi>λ</mi><mn>2</mn></msub><mo>⁢</mo><mfrac><mi>N</mi><mi>d</mi></mfrac></mrow><mo>,</mo><mrow><mi mathvariant="normal">…</mi><mo>⁢</mo><msub><mi>λ</mi><mi>m</mi></msub><mo>⁢</mo><mfrac><mi>N</mi><mi>d</mi></mfrac></mrow></mrow><annotation encoding="application/x-tex">\lambda_{1}\frac{N}{d},\lambda_{2}\frac{N}{d},...\lambda_{m}\frac{N}{d}</annotation></semantics></math>. We want to construct the
same sequence <math id="p9.m3" class="ltx_Math" alttext="a_{k}" display="inline"><semantics><msub><mi>a</mi><mi>k</mi></msub><annotation encoding="application/x-tex">a_{k}</annotation></semantics></math>. Set <math id="p9.m4" class="ltx_Math" alttext="a_{1}=1" display="inline"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_{1}=1</annotation></semantics></math>. For each <math id="p9.m5" class="ltx_Math" alttext="1\leq k&lt;m" display="inline"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\leq k&lt;m</annotation></semantics></math>, we let
<math id="p9.m6" class="ltx_Math" alttext="d_{k}=\frac{d}{a}_{k}" display="inline"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><msub><mfrac><mi>d</mi><mi>a</mi></mfrac><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_{k}=\frac{d}{a}_{k}</annotation></semantics></math> and compute the irreducible fraction
<math id="p9.m7" class="ltx_Math" alttext="\lambda_{k}\frac{N}{d}\frac{a_{k}}{N}=\frac{\lambda_{k}}{d_{k}}=\frac{p_{k}}{q%
_{k}}" display="inline"><semantics><mrow><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>⁢</mo><mfrac><mi>N</mi><mi>d</mi></mfrac><mo>⁢</mo><mfrac><msub><mi>a</mi><mi>k</mi></msub><mi>N</mi></mfrac></mrow><mo>=</mo><mfrac><msub><mi>λ</mi><mi>k</mi></msub><msub><mi>d</mi><mi>k</mi></msub></mfrac><mo>=</mo><mfrac><msub><mi>p</mi><mi>k</mi></msub><msub><mi>q</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\lambda_{k}\frac{N}{d}\frac{a_{k}}{N}=\frac{\lambda_{k}}{d_{k}}=\frac{p_{k}}{q%
_{k}}</annotation></semantics></math>. As above, we have <math id="p9.m8" class="ltx_Math" alttext="{a_{k}q_{k}}|{a_{k}d_{k}}=d" display="inline"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><msub><mi>q</mi><mi>k</mi></msub><mo stretchy="false">|</mo><msub><mi>a</mi><mi>k</mi></msub><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">{a_{k}q_{k}}|{a_{k}d_{k}}=d</annotation></semantics></math> and set
<math id="p9.m9" class="ltx_Math" alttext="a_{k+1}={q_{k}a_{k}}" display="inline"><semantics><mrow><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><msub><mi>q</mi><mi>k</mi></msub><mo>⁢</mo><msub><mi>a</mi><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">a_{k+1}={q_{k}a_{k}}</annotation></semantics></math>.
Now, write the euclidean division <math id="p9.m10" class="ltx_Math" alttext="\lambda_{k}=d_{k}\mu_{k}+\nu_{k}" display="inline"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>=</mo><mrow><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>⁢</mo><msub><mi>μ</mi><mi>k</mi></msub></mrow><mo>+</mo><msub><mi>ν</mi><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\lambda_{k}=d_{k}\mu_{k}+\nu_{k}</annotation></semantics></math> where
<math id="p9.m11" class="ltx_Math" alttext="\mu_{k}\in\{0,...a_{k}-1\}" display="inline"><semantics><mrow><msub><mi>μ</mi><mi>k</mi></msub><mo>∈</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mrow><mrow><mi mathvariant="normal">…</mi><mo>⁢</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">\mu_{k}\in\{0,...a_{k}-1\}</annotation></semantics></math> and <math id="p9.m12" class="ltx_Math" alttext="\nu_{k}\in\{0,...d_{k}-1\}" display="inline"><semantics><mrow><msub><mi>ν</mi><mi>k</mi></msub><mo>∈</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mrow><mrow><mi mathvariant="normal">…</mi><mo>⁢</mo><msub><mi>d</mi><mi>k</mi></msub></mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">\nu_{k}\in\{0,...d_{k}-1\}</annotation></semantics></math> (with
uniform probability for <math id="p9.m13" class="ltx_Math" alttext="\mu_{k}" display="inline"><semantics><msub><mi>μ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\mu_{k}</annotation></semantics></math> and <math id="p9.m14" class="ltx_Math" alttext="\nu_{k}" display="inline"><semantics><msub><mi>ν</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\nu_{k}</annotation></semantics></math> too). We have
<math id="p9.m15" class="ltx_Math" alttext="\frac{p_{k}}{q_{k}}=\frac{\lambda_{k}}{d_{k}}=\mu_{k}+\frac{\nu_{k}}{d_{k}}" display="inline"><semantics><mrow><mfrac><msub><mi>p</mi><mi>k</mi></msub><msub><mi>q</mi><mi>k</mi></msub></mfrac><mo>=</mo><mfrac><msub><mi>λ</mi><mi>k</mi></msub><msub><mi>d</mi><mi>k</mi></msub></mfrac><mo>=</mo><mrow><msub><mi>μ</mi><mi>k</mi></msub><mo>+</mo><mfrac><msub><mi>ν</mi><mi>k</mi></msub><msub><mi>d</mi><mi>k</mi></msub></mfrac></mrow></mrow><annotation encoding="application/x-tex">\frac{p_{k}}{q_{k}}=\frac{\lambda_{k}}{d_{k}}=\mu_{k}+\frac{\nu_{k}}{d_{k}}</annotation></semantics></math> so <math id="p9.m16" class="ltx_Math" alttext="q_{k}" display="inline"><semantics><msub><mi>q</mi><mi>k</mi></msub><annotation encoding="application/x-tex">q_{k}</annotation></semantics></math>
is actually the denominator obtained when we compute the irreducible fraction
<math id="p9.m17" class="ltx_Math" alttext="\frac{\nu_{k}}{d_{k}}" display="inline"><semantics><mfrac><msub><mi>ν</mi><mi>k</mi></msub><msub><mi>d</mi><mi>k</mi></msub></mfrac><annotation encoding="application/x-tex">\frac{\nu_{k}}{d_{k}}</annotation></semantics></math>. With this description, it becomes obvious that the two
algorithms are equivalent (where <math id="p9.m18" class="ltx_Math" alttext="\nu_{k}" display="inline"><semantics><msub><mi>ν</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\nu_{k}</annotation></semantics></math> corresponds to <math id="p9.m19" class="ltx_Math" alttext="\lambda_{k}" display="inline"><semantics><msub><mi>λ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\lambda_{k}</annotation></semantics></math> in the
previous algorithm).</p>
</div>
<div id="p10" class="ltx_para">
<p class="ltx_p">I conjecture that the same phenomenon happens for a general Dedekindian group,
but this may be more difficult to write it down…</p>
</div>


{% endraw %}
