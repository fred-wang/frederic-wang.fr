---
layout: post
title: "Infinite version of the Set card game"
tags: maths igalia
---

{% raw %}

  <p><em>edit 2023/06/17: I elaborated a bit more in the conclusion about the open problem of finding a minimal <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math>.</em></p>

<h2 id="the-set-game">The <em>Set</em> Game</h2>

<p>I visited A Coruña last week for the <a href="https://webengineshackfest.org">Web Engines Hackfest</a> and to participate to internal events with my fellow Igalians. One of our tradition being to play board games, my colleague <a href="https://www.igalia.com/team/idimitriou">Ioanna</a> presented a <a href="https://en.wikipedia.org/wiki/Set_(card_game)">card game called <em>Set</em></a>. To be honest I was not very good at it, but it made me think of a potential generalization for infinite sets that is worth a blog post…</p>

<p>Basically, we have a deck of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>λ</mi><mi>μ</mi></msup><annotation encoding="TeX">\lambda^\mu</annotation></semantics></math> cards with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="TeX">\mu = 4</annotation></semantics></math> features (number of shapes, shape, shading and color), each of them taking <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="TeX">\lambda = 3</annotation></semantics></math> possible values (e.g. red, green or purple for the color). Given <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math> cards on the table, players must extract <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> cards forming what is called a <em>Set</em>, which is defined as follows: for each of the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="TeX">\mu</annotation></semantics></math> features, either the cards use the same value or they use pairwise distinct values.</p>

<p>Formally, this can be generalized for any cardinal <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> as follows:</p>

<ul>
  <li>A card is a function from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="TeX">\mu</annotation></semantics></math> (the features) to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> (the values).</li>
  <li>A set of cards <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math> is a <em>Set</em> iff for any feature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding="TeX">\alpha &lt; \mu</annotation></semantics></math>, the mapping
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">Φ</mi><mi>α</mi><mi>S</mi></msubsup><mo>:</mo><mi>S</mi><mo stretchy="false">→</mo><mi>λ</mi></mrow><annotation encoding="TeX">\Phi_\alpha^S : S \rightarrow \lambda</annotation></semantics></math>
    <p>that maps a card <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="TeX">c</annotation></semantics></math> to the value <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="TeX">c(\alpha)</annotation></semantics></math> is either constant or one-to-one.</p>
  </li>
</ul>

<p>Given a value <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≤</mo><mi>κ</mi><mo>≤</mo><msup><mi>λ</mi><mi>μ</mi></msup></mrow><annotation encoding="TeX">\lambda \leq \kappa \leq \lambda^\mu</annotation></semantics></math>, can we always extract a <em>Set</em> when <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math> cards are put on the table? Or said otherwise, is there a set of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math> cards from which we cannot extract any <em>Set</em>?</p>

<h2 id="trivial-cases-λ2lambda-leq-2-or-μ1mu-leq-1">Trivial cases (<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≤</mo><mn>2</mn></mrow><annotation encoding="TeX">\lambda \leq 2</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="TeX">\mu \leq 1</annotation></semantics></math>)</h2>

<p>Given <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>≥</mo><mi>λ</mi></mrow><annotation encoding="TeX">\kappa \geq \lambda</annotation></semantics></math> cards, we can always extract a <em>Set</em> <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math> in the following trivial cases:</p>

<ul>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="TeX">\mu = 0</annotation></semantics></math> then the deck contains only one card <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mi>∅</mi></mrow><annotation encoding="TeX">c = \emptyset</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="TeX">\lambda \geq 2</annotation></semantics></math> such a set of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math> cards does not exist. Otherwise we can just take <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>∅</mi></mrow><annotation encoding="TeX">S = \emptyset</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="TeX">S ={\{c\}}</annotation></semantics></math>: these are <em>Sets</em> since the definition is trivial for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="TeX">\mu = 0</annotation></semantics></math>.</li>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="TeX">\mu \geq 1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="TeX">\lambda = 0</annotation></semantics></math> then the deck is empty. We take <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>∅</mi></mrow><annotation encoding="TeX">S = \emptyset</annotation></semantics></math> and for any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding="TeX">\alpha &lt; \mu</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">Φ</mi><mi>α</mi><mi>∅</mi></msubsup><mo>=</mo><mi>∅</mi></mrow><annotation encoding="TeX">\Phi_\alpha^\emptyset = \emptyset</annotation></semantics></math> is both constant and one-to-one.</li>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="TeX">\mu = 1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="TeX">\lambda \geq 1</annotation></semantics></math>, a card <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="TeX">c</annotation></semantics></math> is fully determined by its value <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="TeX">c(0)</annotation></semantics></math>, so distinct cards give distinct values. So we can pick any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math> of size <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math>: it is a <em>Set</em> since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Φ</mi><mn>0</mn></msub><annotation encoding="TeX">\Phi_0</annotation></semantics></math> is one-to-one.</li>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="TeX">\lambda = 1</annotation></semantics></math> then we can pick any singleton <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math>: it is a <em>Set</em> since for any feature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding="TeX">\alpha &lt; \mu</annotation></semantics></math> the mapping <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi mathvariant="normal">Φ</mi><mi>α</mi><mi>S</mi></msubsup><annotation encoding="TeX">\Phi_\alpha^S</annotation></semantics></math> is both constant and one-to-one.</li>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="TeX">\lambda = 2</annotation></semantics></math> then we can pick any pair of cards <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math>: it is a <em>Set</em> since for any feature <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding="TeX">\alpha &lt; \mu</annotation></semantics></math> the mapping <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi mathvariant="normal">Φ</mi><mi>α</mi><mi>S</mi></msubsup><annotation encoding="TeX">\Phi_\alpha^S</annotation></semantics></math> is either constant or one-to-one (depending on whether the two cards display the same value or not).</li>
</ul>

<p>👉🏼 For the rest of this blog post, I’ll assume <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="TeX">\mu \geq 2</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="TeX">\lambda \geq 3</annotation></semantics></math>.</p>

<h2 id="not-enough-cards-on-the-table-κμkappa-leq-mu">Not enough cards on the table (<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>≤</mo><mi>μ</mi></mrow><annotation encoding="TeX">\kappa \leq \mu</annotation></semantics></math>)</h2>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>≥</mo><mi>κ</mi><mo>≥</mo><mi>λ</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="TeX">\mu \geq \kappa \geq \lambda \geq 3</annotation></semantics></math> then we consider cards <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>α</mi></msub><annotation encoding="TeX">c_\alpha</annotation></semantics></math> for each <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding="TeX">\alpha &lt; \kappa</annotation></semantics></math> defined for each <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding="TeX">\beta &lt; \mu</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>α</mi></msub><mrow><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><msub><mi>δ</mi><mrow><mi>α</mi><mo>,</mo><mi>β</mi></mrow></msub></mrow><annotation encoding="TeX">c_\alpha{(\beta)} = \delta_{\alpha, \beta} </annotation></semantics></math> (using <a href="https://en.wikipedia.org/wiki/Kronecker_delta">Kronecker delta</a>). If we extract a subset <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math> from these cards and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub><mo>,</mo><msub><mi>α</mi><mn>2</mn></msub><mo>,</mo><msub><mi>α</mi><mn>3</mn></msub><mo>&lt;</mo><mi>κ</mi><mo>≤</mo><mi>μ</mi></mrow><annotation encoding="TeX">\alpha_1, \alpha_2, \alpha_3 &lt; \kappa \leq \mu</annotation></semantics></math> are indices for elements of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math> then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi mathvariant="normal">Φ</mi><msub><mi>α</mi><mn>1</mn></msub><mi>S</mi></msubsup><annotation encoding="TeX">\Phi_{\alpha_1}^S</annotation></semantics></math> respectively evaluates to 1, 0 and 0 for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub><mo>,</mo><msub><mi>α</mi><mn>2</mn></msub><mo>,</mo><msub><mi>α</mi><mn>3</mn></msub></mrow><annotation encoding="TeX">\alpha_1, \alpha_2, \alpha_3</annotation></semantics></math> so <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math> is not a <em>Set</em>.</p>

<p>👉🏼 For the rest of this blog post, we’ll assume <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding="TeX">\mu &lt; \kappa</annotation></semantics></math> and will even focus on the minimal case <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="TeX">\kappa = \lambda</annotation></semantics></math>.</p>

<h2 id="finite-number-of-values-λltℵ0lambda-lt-aleph_0">Finite number of values (<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>&lt;</mo><msub><mi>ℵ</mi><mn>0</mn></msub></mrow><annotation encoding="TeX">\lambda &lt; \aleph_0</annotation></semantics></math>)</h2>

<p>Let’s consider a finite number of values <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="TeX">\lambda \geq 3</annotation></semantics></math> and define the card <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>α</mi></msub><annotation encoding="TeX">c_\alpha</annotation></semantics></math> for each <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>λ</mi></mrow><annotation encoding="TeX">\alpha &lt; \lambda</annotation></semantics></math> as follows: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>α</mi></msub><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>δ</mi><mrow><mi>α</mi><mo>,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="TeX">c_\alpha(\beta) = \delta_{\alpha, 0}</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="TeX">\beta=0</annotation></semantics></math> (again Kronecker delta) and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>α</mi></msub><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><mi>α</mi></mrow><annotation encoding="TeX">c_\alpha(\beta) = \alpha</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>β</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding="TeX">0 &lt; \beta &lt; \mu</annotation></semantics></math>. Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="TeX">\mu \geq 2</annotation></semantics></math>, the latter case shows that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>c</mi><mi>α</mi></msub><mo>:</mo><mi>α</mi><mo>&lt;</mo><mi>λ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="TeX">S = \{ c_\alpha : \alpha &lt; \lambda \}</annotation></semantics></math> contains exactly <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> cards. Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>=</mo><mi>λ</mi><mo>&lt;</mo><msub><mi>ℵ</mi><mn>0</mn></msub></mrow><annotation encoding="TeX">\kappa = \lambda &lt; \aleph_0</annotation></semantics></math>, the only way to extract a subset of size <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> would be to take all the cards. But they don’t form a <em>Set</em> since by construction <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mi mathvariant="normal">Φ</mi><mn>0</mn></msub><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>1</mn><mo>≠</mo><mn>0</mn><mo>=</mo><mrow><msub><mi mathvariant="normal">Φ</mi><mn>0</mn></msub><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi mathvariant="normal">Φ</mi><mn>0</mn></msub><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="TeX">{\Phi_0{(c_0)}} = 1 \neq 0 = {\Phi_0{(c_1)}} = {\Phi_0{(c_2)}}</annotation></semantics></math>.</p>

<p>👉🏼 For the rest of the blog post, I’ll assume <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> is infinite.</p>

<h2 id="singular-number-of-values-cfλltλmicflambda-lt-lambda">Singular number of values (<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cf</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>λ</mi></mrow><annotation encoding="TeX">\mi{cf}(\lambda) &lt; \lambda</annotation></semantics></math>)</h2>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> is a singular cardinal, then we consider a cofinal sequence <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">{</mo><msub><mi>α</mi><mi>γ</mi></msub><mo>,</mo><mi>γ</mi><mo>&lt;</mo><mi>ν</mi><mo stretchy="false">}</mo></mrow><mo>⊆</mo><mi>λ</mi></mrow><annotation encoding="TeX">{\{ \alpha_{\gamma}, \gamma &lt; \nu \}} \subseteq \lambda</annotation></semantics></math> of length <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo>&lt;</mo><mi>λ</mi></mrow><annotation encoding="TeX">\nu &lt; \lambda</annotation></semantics></math> and define the card <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>α</mi></msub><annotation encoding="TeX">c_\alpha</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>λ</mi></mrow><annotation encoding="TeX">\alpha &lt; \lambda</annotation></semantics></math> as follows:</p>

<ul>
  <li>For <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="TeX">\beta = 0</annotation></semantics></math>, we consider the smallest ordinal <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>&lt;</mo><mi>ν</mi><mo>≤</mo><mi>λ</mi></mrow><annotation encoding="TeX">\gamma &lt; \nu \leq \lambda</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><msub><mi>α</mi><mi>γ</mi></msub></mrow><annotation encoding="TeX">\alpha &lt; \alpha_\gamma</annotation></semantics></math> and define <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>α</mi></msub><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>γ</mi></mrow><annotation encoding="TeX">c_\alpha{(0)} = \gamma</annotation></semantics></math>.</li>
  <li>For any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>β</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding="TeX">1 \leq \beta &lt; \mu</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mi>c</mi><mi>α</mi></msub><mrow><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>α</mi></mrow><annotation encoding="TeX">{c_\alpha{(\beta)}} = \alpha</annotation></semantics></math>.</li>
</ul>

<p>Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="TeX">\mu \geq 2</annotation></semantics></math>, the latter case shows that these are <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> distinct cards. Consider <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><mrow><mo stretchy="false">{</mo><msub><mi>c</mi><mi>α</mi></msub><mo>,</mo><mi>α</mi><mo>&lt;</mo><mi>λ</mi><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="TeX">S \subseteq {\{c_\alpha, \alpha &lt; \lambda \}}</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi mathvariant="normal">Φ</mi><mn>0</mn><mi>S</mi></msubsup><annotation encoding="TeX">\Phi_0^S</annotation></semantics></math> evaluates to a constant value <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>&lt;</mo><mi>ν</mi></mrow><annotation encoding="TeX">\gamma &lt; \nu</annotation></semantics></math> then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mrow><mo>(</mo><msubsup><mi mathvariant="normal">Φ</mi><mn>0</mn><mi>S</mi></msubsup><mo>)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>γ</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="TeX">S = {\left(\Phi_0^S\right)}^{-1}(\{\gamma\})</annotation></semantics></math> has size at most <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">|</mo><msub><mi>α</mi><mi>γ</mi></msub><mo stretchy="false">|</mo></mrow><mo>&lt;</mo><mi>λ</mi></mrow><annotation encoding="TeX">{|\alpha_\gamma|} &lt; \lambda</annotation></semantics></math>. If instead <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi mathvariant="normal">Φ</mi><mn>0</mn><mi>S</mi></msubsup><annotation encoding="TeX">\Phi_0^S</annotation></semantics></math> is one-to-one then it takes at most <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ν</mi><annotation encoding="TeX">\nu</annotation></semantics></math> distinct values so again <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo>≤</mo><mi>ν</mi><mo>&lt;</mo><mi>λ</mi></mrow><annotation encoding="TeX">{|S|} \leq \nu &lt; \lambda</annotation></semantics></math>. Hence <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math> is not a <em>Set</em>.</p>

<p>👉🏼 For the rest of the blog post, I’ll assume <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> is an infinite regular cardinal.</p>

<h2 id="finite-number-of-features-μltℵ0mu-lt-aleph_0">Finite number of features (<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>&lt;</mo><msub><mi>ℵ</mi><mn>0</mn></msub></mrow><annotation encoding="TeX">\mu &lt; \aleph_0</annotation></semantics></math>)</h2>

<p>In this section, we assume that the number of features <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="TeX">\mu</annotation></semantics></math> is finite. Let’s consider <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> cards <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>α</mi></msub><annotation encoding="TeX">c_\alpha</annotation></semantics></math> and extract a <em>Set</em> <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math> by induction as follows:</p>

<ul>
  <li>
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>c</mi><mi>α</mi></msub><mo>:</mo><mi>α</mi><mo>&lt;</mo><mi>λ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="TeX">S_0 = \{ c_\alpha : \alpha &lt; \lambda \}</annotation></semantics></math>
  </li>
  <li>For any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding="TeX">\beta &lt; \mu</annotation></semantics></math>, we construct <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>β</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>⊆</mo><msub><mi>S</mi><mi>β</mi></msub></mrow><annotation encoding="TeX">S_{\beta+1} \subseteq S_{\beta}</annotation></semantics></math> of cardinality <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math>. We note that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> is regular and
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mi>β</mi></msub><mo>=</mo><mrow><munder><mo>⋃</mo><mrow><mi>α</mi><mo>∊</mo><msubsup><mi mathvariant="normal">Φ</mi><mi>β</mi><msub><mi>S</mi><mi>β</mi></msub></msubsup><mrow><mo stretchy="false">(</mo><msub><mi>S</mi><mi>β</mi></msub><mo stretchy="false">)</mo></mrow></mrow></munder><msup><mrow><mo>(</mo><msubsup><mi mathvariant="normal">Φ</mi><mi>β</mi><msub><mi>S</mi><mi>β</mi></msub></msubsup><mo>)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>α</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="TeX">
S_\beta = {\bigcup_{\alpha \in \Phi_\beta^{S_\beta}{(S_\beta)}}
         {\left(\Phi_\beta^{S_\beta}\right)}^{-1}{(\{\alpha\})}
              }
</annotation></semantics></math>
    <p>so there are only two possible cases:</p>
    <ul>
      <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">Φ</mi><mi>β</mi><msub><mi>S</mi><mi>β</mi></msub></msubsup><mrow><mo stretchy="false">(</mo><msub><mi>S</mi><mi>β</mi></msub><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="TeX">\Phi_\beta^{S_\beta}{(S_\beta)}</annotation></semantics></math> is of cardinality <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> then pick <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> elements from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>S</mi><mi>β</mi></msub><annotation encoding="TeX">S_\beta</annotation></semantics></math> with pairwise distinct image by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi mathvariant="normal">Φ</mi><mi>β</mi><msub><mi>S</mi><mi>β</mi></msub></msubsup><annotation encoding="TeX">\Phi_\beta^{S_\beta}</annotation></semantics></math>.</li>
      <li>Otherwise, if there is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>λ</mi></mrow><annotation encoding="TeX">\alpha &lt; \lambda</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo>(</mo><msubsup><mi mathvariant="normal">Φ</mi><mi>β</mi><msub><mi>S</mi><mi>β</mi></msub></msubsup><mo>)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>α</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="TeX">{\left(\Phi_\beta^{S_\beta}\right)}^{-1}{(\{\alpha\})}</annotation></semantics></math> is of cardinality <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math>, then let it be our <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>S</mi><mrow><mi>β</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="TeX">S_{\beta+1}</annotation></semantics></math>.</li>
    </ul>
  </li>
  <li>
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mi>S</mi><mi>μ</mi></msub></mrow><annotation encoding="TeX">S = S_{\mu}</annotation></semantics></math>
  </li>
</ul>

<p>Then by construction, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="TeX">S</annotation></semantics></math> is of size <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> and for any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding="TeX">\beta &lt; \mu</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><msub><mi>S</mi><mrow><mi>β</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="TeX">S \subseteq S_{\beta+1}</annotation></semantics></math> which means that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">Φ</mi><mi>β</mi><mi>S</mi></msubsup><mo>=</mo><msub><mrow><mo stretchy="false">(</mo><msubsup><mi mathvariant="normal">Φ</mi><mi>β</mi><msub><mi>S</mi><mi>β</mi></msub></msubsup><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">|</mo><mi>S</mi></mrow></msub></mrow><annotation encoding="TeX">\Phi_\beta^S =
 {
 {(\Phi_\beta^{S_\beta})}_{| S}}</annotation></semantics></math> is either constant or one-to-one.</p>

<p>Incidentally, although I said I would focus on the case <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="TeX">\kappa = \lambda</annotation></semantics></math> the result of this session shows that we can extract a <em>Set</em> if more than <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> cards are put on the table!</p>

<h2 id="summary-and-open-questions">Summary and open questions</h2>

<p>Above are the results I found from a preliminary investigation, which can be summarized as follows:</p>

<ol>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≤</mo><mn>2</mn></mrow><annotation encoding="TeX">\lambda \leq 2</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="TeX">\mu \leq 1</annotation></semantics></math> then we can always find a <em>Set</em> from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>≥</mo><mi>λ</mi></mrow><annotation encoding="TeX">\kappa \geq \lambda</annotation></semantics></math> cards.</li>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>≤</mo><mi>λ</mi><mo>≤</mo><mi>μ</mi></mrow><annotation encoding="TeX">3 \leq \lambda \leq \mu</annotation></semantics></math> then for any <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≤</mo><mi>κ</mi><mo>≤</mo><mi>μ</mi></mrow><annotation encoding="TeX">\lambda \leq \kappa \leq \mu</annotation></semantics></math> there is a set of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math> cards from which we cannot extract any <em>Set</em>.</li>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>μ</mi><mo>&lt;</mo><mi>λ</mi><mo>&lt;</mo><msub><mi>ℵ</mi><mn>0</mn></msub></mrow><annotation encoding="TeX">2 \leq \mu &lt; \lambda &lt; \aleph_0</annotation></semantics></math> there is a set of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> cards from which we cannot extract any <em>Set</em>.</li>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>μ</mi></mrow><annotation encoding="TeX">2 \leq \mu</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> is singular then there is a set of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> cards from which we cannot extract any <em>Set</em>.</li>
  <li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>μ</mi><mo>&lt;</mo><msub><mi>ℵ</mi><mn>0</mn></msub><mo>≤</mo><mrow><mi>cf</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>λ</mi></mrow><annotation encoding="TeX">2 \leq \mu &lt; \aleph_0 \leq {\mi{cf}(\lambda)} = \lambda</annotation></semantics></math>, then we can always find a <em>Set</em> from <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>≥</mo><mi>λ</mi></mrow><annotation encoding="TeX">\kappa \geq \lambda</annotation></semantics></math> cards.</li>
</ol>

<p>Note that for the standard game <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>=</mo><mi>λ</mi><mo>&lt;</mo><mi>μ</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="TeX">3 = \lambda &lt; \mu = 4</annotation></semantics></math> the only of the results above that applies is (2). Indeed, having only three or four cards on the table is generally not enough to extract a <em>Set</em>!</p>

<p>So far, I was not able to find an answer for the case <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ℵ</mi><mn>0</mn></msub><mo>≤</mo><mi>μ</mi><mo>&lt;</mo><mrow><mi>cf</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>λ</mi><mo>≤</mo><mi>κ</mi></mrow><annotation encoding="TeX">\aleph_0 \leq \mu &lt; {\mi{cf}(\lambda)} = \lambda \leq \kappa</annotation></semantics></math>. It looks like the inductive construction from the previous paragraph could work, but it’s not clear what guarantees that taking intersection at limit step would preserve size <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math> (an idea would be to use closed unbounded <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>S</mi><mi>β</mi></msub><annotation encoding="TeX">S_\beta</annotation></semantics></math> instead but I didn’t find a satisfying proof). I also failed to build a counter-example set of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="TeX">\lambda</annotation></semantics></math> cards without any <em>Set</em> subset, despite several attempts.</p>

<p>More generally, an open problem is to determine the minimal number of cards <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="TeX">\kappa</annotation></semantics></math> (with <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≤</mo><mi>κ</mi><mo>≤</mo><msup><mi>λ</mi><mi>μ</mi></msup></mrow><annotation encoding="TeX">\lambda \leq \kappa \leq \lambda^\mu</annotation></semantics></math>) to put on the table to ensure players can always extract a <em>Set</em> subset… or even if such a number actually exists! If it does, then in cases (2) (3) (4) we only know <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>&gt;</mo><mi>λ</mi></mrow><annotation encoding="TeX">\kappa &gt; \lambda</annotation></semantics></math>. In cases (1) and (5) the minimum value <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="TeX">\kappa = \lambda</annotation></semantics></math> works ; and when <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="TeX">\mu \geq 2</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="TeX">\lambda \geq 3</annotation></semantics></math> are finite, the maximum value <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>=</mo><msup><mi>λ</mi><mi>μ</mi></msup></mrow><annotation encoding="TeX">\kappa = \lambda^\mu</annotation></semantics></math> means taking the full deck, which works too (e.g. it always contains the <em>Set</em> given by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>α</mi><mo>&lt;</mo><mi>λ</mi><mo>,</mo><mo>∀</mo><mi>β</mi><mo>&lt;</mo><mi>μ</mi><mo>,</mo><msub><mi>c</mi><mi>α</mi></msub><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><mi>α</mi></mrow><annotation encoding="TeX">\forall \alpha &lt; \lambda, \forall \beta &lt; \mu, c_\alpha(\beta) = \alpha</annotation></semantics></math>). Incidentally, note that the latter case is consistent with (2) and (3) since we have <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>λ</mi><mi>μ</mi></msup><mo>&gt;</mo><mi>μ</mi><mo>,</mo><mi>λ</mi></mrow><annotation encoding="TeX">\lambda^\mu &gt; \mu, \lambda</annotation></semantics></math>. But in general for infinite parameters putting <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>=</mo><msup><mi>λ</mi><mi>μ</mi></msup></mrow><annotation encoding="TeX">\kappa = \lambda^\mu</annotation></semantics></math> cards on the table does not mean putting the full deck, so it’s less obvious whether we can extract a <em>Set</em>…</p>
{% endraw %}
