---
layout: post
title: "Exercises in Set Theory: Ultrafilters and Boolean algebras"
tags: maths
---

{% raw %}

  
<div id="p1" class="ltx_para">
<p class="ltx_p">Since my
previous blog post, I have been
working on exercises from chapter 7 of Thomas Jech’s book "Set Theory".
I’ve published my solutions but I’m not yet done with exercises 7.22 and
7.28 which seem to be generalizations of theorems 4.3 and 3.2.
I guess that before coming back to these two exercises,
I’ll consider the content and exercises of subsequent chapters…</p>
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p">I had the opportunity to read chapter 7 again and to study more
precisely the correctness of some claims
(you know, those that are "clearly seen to be obvious
via an easy proof based on a straightforward argument that makes them
trivial" but actually take time before really being understood)
I describe below the two statements for which the ratio between the time
I spent on them and the length of the proof provided was the
largest. I indicate the arguments I used to convince myself.
I also had trouble to
understand the proof of theorem 7.15 but most of the required arguments can
actually be found in the exercices.</p>
</div>
<div id="p3" class="ltx_para">
<p class="ltx_p">The first part of the chapter essentially deals with <a href="https://en.wikipedia.org/wiki/Ultrafilter#Formal_definition" title="" class="ltx_ref">ultrafilters</a> on an infinite set.
In particular,
a nonprincipal ultrafilter <math id="p3.m1" class="ltx_Math" alttext="U" display="inline"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> on <math id="p3.m2" class="ltx_Math" alttext="\omega" display="inline"><semantics><mi>ω</mi><annotation encoding="application/x-tex">\omega</annotation></semantics></math> is a Ramsey ultrafilter if for
every partition <math id="p3.m3" class="ltx_Math" alttext="\{A_{n}|n&lt;\omega\}" display="inline"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">|</mo><mrow><mi>n</mi><mo>&lt;</mo><mi>ω</mi></mrow><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{A_{n}|n&lt;\omega\}</annotation></semantics></math> of <math id="p3.m4" class="ltx_Math" alttext="\omega" display="inline"><semantics><mi>ω</mi><annotation encoding="application/x-tex">\omega</annotation></semantics></math> into <math id="p3.m5" class="ltx_Math" alttext="\aleph_{0}" display="inline"><semantics><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\aleph_{0}</annotation></semantics></math> pieces
such that <math id="p3.m6" class="ltx_Math" alttext="\forall n,A_{n}\notin U" display="inline"><semantics><mrow><mrow><mrow><mo>∀</mo><mi>n</mi></mrow><mo>,</mo><msub><mi>A</mi><mi>n</mi></msub></mrow><mo>∉</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">\forall n,A_{n}\notin U</annotation></semantics></math>, there exists <math id="p3.m7" class="ltx_Math" alttext="X\in U" display="inline"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">X\in U</annotation></semantics></math> such that
<math id="p3.m8" class="ltx_Math" alttext="\forall n,\left|X\cap A_{n}\right|=1" display="inline"><semantics><mrow><mrow><mrow><mo>∀</mo><mi>n</mi></mrow><mo>,</mo><mrow><mo>|</mo><mrow><mi>X</mi><mo>∩</mo><msub><mi>A</mi><mi>n</mi></msub></mrow><mo>|</mo></mrow></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\forall n,\left|X\cap A_{n}\right|=1</annotation></semantics></math>. We have:</p>
</div>
<div id="Thmtheorem1" class="ltx_theorem ltx_theorem_theorem">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Theorem 1</span>.</h6>
<div id="Thmtheorem1.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">The continuum hypothesis implies the existence of a Ramsey ultrafilter.</span></p>
</div>
</div>
<div class="ltx_proof">
<h6 class="ltx_title ltx_runin ltx_font_italic ltx_title_proof">Proof.</h6>
<div id="p4" class="ltx_para">
<p class="ltx_p">The proof given in the book is to consider an enumeration
<math id="p4.m1" class="ltx_Math" alttext="\mathcal{A}_{\alpha},\alpha&lt;\omega_{1}" display="inline"><semantics><mrow><mrow><msub><mi class="ltx_font_mathcaligraphic">𝒜</mi><mi>α</mi></msub><mo>,</mo><mi>α</mi></mrow><mo>&lt;</mo><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{A}_{\alpha},\alpha&lt;\omega_{1}</annotation></semantics></math> of all partitions of <math id="p4.m2" class="ltx_Math" alttext="\omega" display="inline"><semantics><mi>ω</mi><annotation encoding="application/x-tex">\omega</annotation></semantics></math> and to
construct by induction a sequence <math id="p4.m3" class="ltx_Math" alttext="{(X_{\alpha})}_{\alpha&lt;\omega_{1}}" display="inline"><semantics><msub><mrow><mo stretchy="false">(</mo><msub><mi>X</mi><mi>α</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>α</mi><mo>&lt;</mo><msub><mi>ω</mi><mn>1</mn></msub></mrow></msub><annotation encoding="application/x-tex">{(X_{\alpha})}_{\alpha&lt;\omega_{1}}</annotation></semantics></math> of
infinite subsets. <math id="p4.m4" class="ltx_Math" alttext="X_{\alpha+1}\subseteq X_{\alpha}" display="inline"><semantics><mrow><msub><mi>X</mi><mrow><mi>α</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>⊆</mo><msub><mi>X</mi><mi>α</mi></msub></mrow><annotation encoding="application/x-tex">X_{\alpha+1}\subseteq X_{\alpha}</annotation></semantics></math>
is chosen to be included in some element of
<math id="p4.m5" class="ltx_Math" alttext="\mathcal{A}_{\alpha}" display="inline"><semantics><msub><mi class="ltx_font_mathcaligraphic">𝒜</mi><mi>α</mi></msub><annotation encoding="application/x-tex">\mathcal{A}_{\alpha}</annotation></semantics></math> or to intersect each of them at, at most, one element.
For <math id="p4.m6" class="ltx_Math" alttext="\alpha" display="inline"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> limit, <math id="p4.m7" class="ltx_Math" alttext="X_{\alpha}" display="inline"><semantics><msub><mi>X</mi><mi>α</mi></msub><annotation encoding="application/x-tex">X_{\alpha}</annotation></semantics></math> is chosen such that
<math id="p4.m8" class="ltx_Math" alttext="X_{\alpha}\setminus X_{\beta}" display="inline"><semantics><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><msub><mi>X</mi><mi>β</mi></msub></mrow><annotation encoding="application/x-tex">X_{\alpha}\setminus X_{\beta}</annotation></semantics></math> is finite for all <math id="p4.m9" class="ltx_Math" alttext="\beta&lt;\alpha" display="inline"><semantics><mrow><mi>β</mi><mo>&lt;</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta&lt;\alpha</annotation></semantics></math>. Such a
<math id="p4.m10" class="ltx_Math" alttext="X_{\alpha}" display="inline"><semantics><msub><mi>X</mi><mi>α</mi></msub><annotation encoding="application/x-tex">X_{\alpha}</annotation></semantics></math> is claimed to exist because <math id="p4.m11" class="ltx_Math" alttext="\alpha&lt;\omega_{1}" display="inline"><semantics><mrow><mi>α</mi><mo>&lt;</mo><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\alpha&lt;\omega_{1}</annotation></semantics></math> is countable.
Finally, <math id="p4.m12" class="ltx_Math" alttext="D=\{X:X\supseteq X_{\alpha}\text{ for some }\alpha&lt;\omega_{1}\}" display="inline"><semantics><mrow><mi>D</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mi>X</mi><mo>:</mo><mrow><mi>X</mi><mo>⊇</mo><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>⁢</mo><mtext> for some </mtext><mo>⁢</mo><mi>α</mi></mrow><mo>&lt;</mo><msub><mi>ω</mi><mn>1</mn></msub></mrow><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">D=\{X:X\supseteq X_{\alpha}\text{ for some }\alpha&lt;\omega_{1}\}</annotation></semantics></math> is claimed to be a Ramsey ultrafilter.</p>
</div>
<div id="p5" class="ltx_para">
<p class="ltx_p">∎</p>
</div>
</div>
<div id="p6" class="ltx_para">
<p class="ltx_p">There were several points that were not obvious to me. First, it’s good to
count the number of partitions of <math id="p6.m1" class="ltx_Math" alttext="\omega" display="inline"><semantics><mi>ω</mi><annotation encoding="application/x-tex">\omega</annotation></semantics></math>.
On the one hand, given any <math id="p6.m2" class="ltx_Math" alttext="A_{0}\subseteq\omega" display="inline"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub><mo>⊆</mo><mi>ω</mi></mrow><annotation encoding="application/x-tex">A_{0}\subseteq\omega</annotation></semantics></math> which is neither
empty nor cofinite we can define a partition of <math id="p6.m3" class="ltx_Math" alttext="\omega" display="inline"><semantics><mi>ω</mi><annotation encoding="application/x-tex">\omega</annotation></semantics></math> by
<math id="p6.m4" class="ltx_Math" alttext="\forall n&lt;\omega,A_{n+1}=\left\{\min{\left({\omega\setminus{\cup_{m\leq n}A_{m%
}}}\right)}\right\}" display="inline"><semantics><mrow><mo>∀</mo><mi>n</mi><mo>&lt;</mo><mi>ω</mi><mo>,</mo><msub><mi>A</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mo>{</mo><mi>min</mi><mrow><mo>(</mo><mi>ω</mi><mo>∖</mo><msub><mo>∪</mo><mrow><mi>m</mi><mo>≤</mo><mi>n</mi></mrow></msub><msub><mi>A</mi><mi>m</mi></msub><mo>)</mo></mrow><mo>}</mo></mrow></mrow><annotation encoding="application/x-tex">\forall n&lt;\omega,A_{n+1}=\left\{\min{\left({\omega\setminus{\cup_{m\leq n}A_{m%
}}}\right)}\right\}</annotation></semantics></math>
and so there are at least <math id="p6.m5" class="ltx_Math" alttext="2^{\aleph_{0}}" display="inline"><semantics><msup><mn>2</mn><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></msup><annotation encoding="application/x-tex">2^{\aleph_{0}}</annotation></semantics></math> such partitions
(cofinite subsets are in bijection with finite subsets
and <math id="p6.m6" class="ltx_Math" alttext="|\omega^{&lt;\omega}|=\aleph_{0}" display="inline"><semantics><mrow><mrow><mo stretchy="false">|</mo><msup><mi>ω</mi><mrow><mi></mi><mo>&lt;</mo><mi>ω</mi></mrow></msup><mo stretchy="false">|</mo></mrow><mo>=</mo><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">|\omega^{&lt;\omega}|=\aleph_{0}</annotation></semantics></math>). On the other hand,
a partition is determined by the family of subsets <math id="p6.m7" class="ltx_Math" alttext="\{A_{n}|n&lt;\omega\}" display="inline"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">|</mo><mrow><mi>n</mi><mo>&lt;</mo><mi>ω</mi></mrow><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{A_{n}|n&lt;\omega\}</annotation></semantics></math>
and so there are at most
<math id="p6.m8" class="ltx_Math" alttext="{\left(2^{\aleph_{0}}\right)}^{\aleph_{0}}=2^{\aleph_{0}}" display="inline"><semantics><mrow><msup><mrow><mo>(</mo><msup><mn>2</mn><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></msup><mo>)</mo></mrow><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></msup><mo>=</mo><msup><mn>2</mn><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></msup></mrow><annotation encoding="application/x-tex">{\left(2^{\aleph_{0}}\right)}^{\aleph_{0}}=2^{\aleph_{0}}</annotation></semantics></math> such partitions.
Since we assume the continuum hypothesis <math id="p6.m9" class="ltx_Math" alttext="2^{\aleph_{0}}=\aleph_{1}" display="inline"><semantics><mrow><msup><mn>2</mn><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></msup><mo>=</mo><msub><mi mathvariant="normal">ℵ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">2^{\aleph_{0}}=\aleph_{1}</annotation></semantics></math> we
get the enumeration <math id="p6.m10" class="ltx_Math" alttext="\mathcal{A}_{\alpha},\alpha&lt;\omega_{1}" display="inline"><semantics><mrow><mrow><msub><mi class="ltx_font_mathcaligraphic">𝒜</mi><mi>α</mi></msub><mo>,</mo><mi>α</mi></mrow><mo>&lt;</mo><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{A}_{\alpha},\alpha&lt;\omega_{1}</annotation></semantics></math>.</p>
</div>
<div id="p7" class="ltx_para">
<p class="ltx_p">Next, I’m not even sure that as it is defined <math id="p7.m1" class="ltx_Math" alttext="D" display="inline"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> is a filter.
Because <math id="p7.m2" class="ltx_Math" alttext="X_{\alpha}" display="inline"><semantics><msub><mi>X</mi><mi>α</mi></msub><annotation encoding="application/x-tex">X_{\alpha}</annotation></semantics></math>
is infinite <math id="p7.m3" class="ltx_Math" alttext="\emptyset\notin D" display="inline"><semantics><mrow><mi mathvariant="normal">∅</mi><mo>∉</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">\emptyset\notin D</annotation></semantics></math> and
<math id="p7.m4" class="ltx_Math" alttext="Y\supseteq X\supseteq X_{\alpha}\implies Y\in D" display="inline"><semantics><mrow><mi>Y</mi><mo>⊇</mo><mi>X</mi><mo>⊇</mo><msub><mi>X</mi><mi>α</mi></msub><mo>⟹</mo><mi>Y</mi><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">Y\supseteq X\supseteq X_{\alpha}\implies Y\in D</annotation></semantics></math> but if
<math id="p7.m5" class="ltx_Math" alttext="X\supseteq X_{\alpha}" display="inline"><semantics><mrow><mi>X</mi><mo>⊇</mo><msub><mi>X</mi><mi>α</mi></msub></mrow><annotation encoding="application/x-tex">X\supseteq X_{\alpha}</annotation></semantics></math> and <math id="p7.m6" class="ltx_Math" alttext="Y\supseteq X_{\beta}" display="inline"><semantics><mrow><mi>Y</mi><mo>⊇</mo><msub><mi>X</mi><mi>β</mi></msub></mrow><annotation encoding="application/x-tex">Y\supseteq X_{\beta}</annotation></semantics></math>, it does not seem
really clear which <math id="p7.m7" class="ltx_Math" alttext="X_{\gamma}\subseteq X\cap Y" display="inline"><semantics><mrow><msub><mi>X</mi><mi>γ</mi></msub><mo>⊆</mo><mrow><mi>X</mi><mo>∩</mo><mi>Y</mi></mrow></mrow><annotation encoding="application/x-tex">X_{\gamma}\subseteq X\cap Y</annotation></semantics></math>. However, if
<math id="p7.m8" class="ltx_Math" alttext="U" display="inline"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> is a nonprincipal ultrafilter a remark from chapter 10 suggests that
<math id="p7.m9" class="ltx_Math" alttext="U" display="inline"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> does not contain any finite set. By exercise 7.3, this is equivalent
to the fact that <math id="p7.m10" class="ltx_Math" alttext="U" display="inline"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> does not contain any singleton <math id="p7.m11" class="ltx_Math" alttext="\{\alpha\}" display="inline"><semantics><mrow><mo stretchy="false">{</mo><mi>α</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\alpha\}</annotation></semantics></math>. This
latter point is easy to verify: if we assume the contrary, because <math id="p7.m12" class="ltx_Math" alttext="U" display="inline"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> is
nonprincipal,
there exists <math id="p7.m13" class="ltx_Math" alttext="X\in U" display="inline"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">X\in U</annotation></semantics></math> such that <math id="p7.m14" class="ltx_Math" alttext="X\nsupseteq\{\alpha\}" display="inline"><semantics><mrow><mi>X</mi><mo>⊉</mo><mrow><mo stretchy="false">{</mo><mi>α</mi><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">X\nsupseteq\{\alpha\}</annotation></semantics></math> and so
<math id="p7.m15" class="ltx_Math" alttext="\kappa\setminus X\supseteq\{\alpha\}" display="inline"><semantics><mrow><mrow><mi>κ</mi><mo>∖</mo><mi>X</mi></mrow><mo>⊇</mo><mrow><mo stretchy="false">{</mo><mi>α</mi><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa\setminus X\supseteq\{\alpha\}</annotation></semantics></math> would be in <math id="p7.m16" class="ltx_Math" alttext="U" display="inline"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>. Hence any
ultrafilter containing <math id="p7.m17" class="ltx_Math" alttext="D" display="inline"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> should also contain
<math id="p7.m18" class="ltx_Math" alttext="E=\{X:\exists\alpha&lt;\omega_{1},\exists x\in\kappa^{&lt;\omega},X\supseteq X_{%
\alpha}\setminus x\}" display="inline"><semantics><mrow><mi>E</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mi>X</mi><mo>:</mo><mrow><mrow><mrow><mo>∃</mo><mi>α</mi></mrow><mo>&lt;</mo><msub><mi>ω</mi><mn>1</mn></msub></mrow><mo>,</mo><mrow><mrow><mrow><mo>∃</mo><mi>x</mi></mrow><mo>∈</mo><msup><mi>κ</mi><mrow><mi></mi><mo>&lt;</mo><mi>ω</mi></mrow></msup></mrow><mo>,</mo><mrow><mi>X</mi><mo>⊇</mo><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><mi>x</mi></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">E=\{X:\exists\alpha&lt;\omega_{1},\exists x\in\kappa^{&lt;\omega},X\supseteq X_{%
\alpha}\setminus x\}</annotation></semantics></math>. <math id="p7.m19" class="ltx_Math" alttext="E" display="inline"><semantics><mi>E</mi><annotation encoding="application/x-tex">E</annotation></semantics></math> is a filter: the arguments above
still hold and <math id="p7.m20" class="ltx_Math" alttext="X\supseteq X_{\alpha}\setminus x\wedge Y\supseteq X_{\beta}\setminus y\implies
X%
\cap Y\supseteq X_{\alpha}\cap X_{\beta}-(x\cup y)\supseteq X_{\alpha}%
\setminus(X_{\alpha}\setminus X_{\beta}\cup x\cup y)" display="inline"><semantics><mrow><mi>X</mi><mo>⊇</mo><mrow><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><mi>x</mi></mrow><mo>∧</mo><mi>Y</mi></mrow><mo>⊇</mo><mrow><msub><mi>X</mi><mi>β</mi></msub><mo>∖</mo><mi>y</mi></mrow><mo>⟹</mo><mrow><mi>X</mi><mo>∩</mo><mi>Y</mi></mrow><mo>⊇</mo><mrow><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∩</mo><msub><mi>X</mi><mi>β</mi></msub></mrow><mo>-</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>∪</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>⊇</mo><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><msub><mi>X</mi><mi>β</mi></msub></mrow><mo>∪</mo><mi>x</mi><mo>∪</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">X\supseteq X_{\alpha}\setminus x\wedge Y\supseteq X_{\beta}\setminus y\implies
X%
\cap Y\supseteq X_{\alpha}\cap X_{\beta}-(x\cup y)\supseteq X_{\alpha}%
\setminus(X_{\alpha}\setminus X_{\beta}\cup x\cup y)</annotation></semantics></math> and so we
only need to verify that <math id="p7.m21" class="ltx_Math" alttext="X_{\alpha}\setminus X_{\beta}" display="inline"><semantics><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><msub><mi>X</mi><mi>β</mi></msub></mrow><annotation encoding="application/x-tex">X_{\alpha}\setminus X_{\beta}</annotation></semantics></math> is finite if
<math id="p7.m22" class="ltx_Math" alttext="\beta&lt;\alpha" display="inline"><semantics><mrow><mi>β</mi><mo>&lt;</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta&lt;\alpha</annotation></semantics></math>. This is already what is claimed for <math id="p7.m23" class="ltx_Math" alttext="\alpha" display="inline"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> a limit
ordinal. In general if <math id="p7.m24" class="ltx_Math" alttext="\gamma" display="inline"><semantics><mi>γ</mi><annotation encoding="application/x-tex">\gamma</annotation></semantics></math> is the greatest limit ordinal such that
<math id="p7.m25" class="ltx_Math" alttext="\gamma\leq\alpha" display="inline"><semantics><mrow><mi>γ</mi><mo>≤</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\gamma\leq\alpha</annotation></semantics></math> then by construction,
<math id="p7.m26" class="ltx_Math" alttext="X_{\gamma}\supseteq X_{\gamma+1}\supseteq...\supseteq X_{\alpha}" display="inline"><semantics><mrow><msub><mi>X</mi><mi>γ</mi></msub><mo>⊇</mo><msub><mi>X</mi><mrow><mi>γ</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>⊇</mo><mi mathvariant="normal">…</mi><mo>⊇</mo><msub><mi>X</mi><mi>α</mi></msub></mrow><annotation encoding="application/x-tex">X_{\gamma}\supseteq X_{\gamma+1}\supseteq...\supseteq X_{\alpha}</annotation></semantics></math> and
so <math id="p7.m27" class="ltx_Math" alttext="X_{\alpha}\setminus X_{\beta}" display="inline"><semantics><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><msub><mi>X</mi><mi>β</mi></msub></mrow><annotation encoding="application/x-tex">X_{\alpha}\setminus X_{\beta}</annotation></semantics></math> is empty if <math id="p7.m28" class="ltx_Math" alttext="\gamma\leq\beta\leq\alpha" display="inline"><semantics><mrow><mi>γ</mi><mo>≤</mo><mi>β</mi><mo>≤</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\gamma\leq\beta\leq\alpha</annotation></semantics></math>
and <math id="p7.m29" class="ltx_Math" alttext="X_{\alpha}\setminus X_{\beta}\subseteq X_{\gamma}\setminus X_{\beta}" display="inline"><semantics><mrow><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><msub><mi>X</mi><mi>β</mi></msub></mrow><mo>⊆</mo><mrow><msub><mi>X</mi><mi>γ</mi></msub><mo>∖</mo><msub><mi>X</mi><mi>β</mi></msub></mrow></mrow><annotation encoding="application/x-tex">X_{\alpha}\setminus X_{\beta}\subseteq X_{\gamma}\setminus X_{\beta}</annotation></semantics></math> is finite if <math id="p7.m30" class="ltx_Math" alttext="\beta&lt;\gamma" display="inline"><semantics><mrow><mi>β</mi><mo>&lt;</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">\beta&lt;\gamma</annotation></semantics></math>.
So we can replace <math id="p7.m31" class="ltx_Math" alttext="D" display="inline"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> by a "ultrafilter extending <math id="p7.m32" class="ltx_Math" alttext="E" display="inline"><semantics><mi>E</mi><annotation encoding="application/x-tex">E</annotation></semantics></math>". It’s not
too difficult to check that a ultrafilter containing <math id="p7.m33" class="ltx_Math" alttext="D" display="inline"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> must be Ramsey.
For any partition <math id="p7.m34" class="ltx_Math" alttext="\mathcal{A}_{\alpha}" display="inline"><semantics><msub><mi class="ltx_font_mathcaligraphic">𝒜</mi><mi>α</mi></msub><annotation encoding="application/x-tex">\mathcal{A}_{\alpha}</annotation></semantics></math> then by construction either
<math id="p7.m35" class="ltx_Math" alttext="X_{\alpha+1}\subseteq A_{n}" display="inline"><semantics><mrow><msub><mi>X</mi><mrow><mi>α</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>⊆</mo><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_{\alpha+1}\subseteq A_{n}</annotation></semantics></math> for some <math id="p7.m36" class="ltx_Math" alttext="n&lt;\omega" display="inline"><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>ω</mi></mrow><annotation encoding="application/x-tex">n&lt;\omega</annotation></semantics></math> and so <math id="p7.m37" class="ltx_Math" alttext="A_{n}\in D" display="inline"><semantics><mrow><msub><mi>A</mi><mi>n</mi></msub><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">A_{n}\in D</annotation></semantics></math> or
<math id="p7.m38" class="ltx_Math" alttext="\forall n&lt;\omega,|X_{\alpha+1}\cap A_{n}|\leq 1" display="inline"><semantics><mrow><mrow><mrow><mo>∀</mo><mi>n</mi></mrow><mo>&lt;</mo><mi>ω</mi></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">|</mo><mrow><msub><mi>X</mi><mrow><mi>α</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>∩</mo><msub><mi>A</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow><mo>≤</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">\forall n&lt;\omega,|X_{\alpha+1}\cap A_{n}|\leq 1</annotation></semantics></math>. In the latter case
we can find <math id="p7.m39" class="ltx_Math" alttext="X\supseteq X_{\alpha+1}" display="inline"><semantics><mrow><mi>X</mi><mo>⊇</mo><msub><mi>X</mi><mrow><mi>α</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">X\supseteq X_{\alpha+1}</annotation></semantics></math> (so <math id="p7.m40" class="ltx_Math" alttext="X\in D" display="inline"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">X\in D</annotation></semantics></math>) such that
<math id="p7.m41" class="ltx_Math" alttext="\forall n,|X\cap A_{n}|=1" display="inline"><semantics><mrow><mrow><mrow><mo>∀</mo><mi>n</mi></mrow><mo>,</mo><mrow><mo stretchy="false">|</mo><mrow><mi>X</mi><mo>∩</mo><msub><mi>A</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\forall n,|X\cap A_{n}|=1</annotation></semantics></math> (we pick one element from each <math id="p7.m42" class="ltx_Math" alttext="A_{n}" display="inline"><semantics><msub><mi>A</mi><mi>n</mi></msub><annotation encoding="application/x-tex">A_{n}</annotation></semantics></math> such
that <math id="p7.m43" class="ltx_Math" alttext="X_{\alpha+1}\cap A_{n}=\emptyset" display="inline"><semantics><mrow><mrow><msub><mi>X</mi><mrow><mi>α</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>∩</mo><msub><mi>A</mi><mi>n</mi></msub></mrow><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">X_{\alpha+1}\cap A_{n}=\emptyset</annotation></semantics></math> and put these elements into <math id="p7.m44" class="ltx_Math" alttext="X" display="inline"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>).</p>
</div>
<div id="p8" class="ltx_para">
<p class="ltx_p">Finally, the most difficult part was to understand how the sequence
<math id="p8.m1" class="ltx_Math" alttext="{(X_{\alpha})}_{\alpha&lt;\omega_{1}}" display="inline"><semantics><msub><mrow><mo stretchy="false">(</mo><msub><mi>X</mi><mi>α</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>α</mi><mo>&lt;</mo><msub><mi>ω</mi><mn>1</mn></msub></mrow></msub><annotation encoding="application/x-tex">{(X_{\alpha})}_{\alpha&lt;\omega_{1}}</annotation></semantics></math> can be built. We can choose <math id="p8.m2" class="ltx_Math" alttext="X_{0}" display="inline"><semantics><msub><mi>X</mi><mn>0</mn></msub><annotation encoding="application/x-tex">X_{0}</annotation></semantics></math> arbitrarily
as this set is not involved in the arguments above.
For any <math id="p8.m3" class="ltx_Math" alttext="\alpha&lt;\omega_{1}" display="inline"><semantics><mrow><mi>α</mi><mo>&lt;</mo><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\alpha&lt;\omega_{1}</annotation></semantics></math>, if there exists some
<math id="p8.m4" class="ltx_Math" alttext="A\in\mathcal{A}_{\alpha}" display="inline"><semantics><mrow><mi>A</mi><mo>∈</mo><msub><mi class="ltx_font_mathcaligraphic">𝒜</mi><mi>α</mi></msub></mrow><annotation encoding="application/x-tex">A\in\mathcal{A}_{\alpha}</annotation></semantics></math> such that <math id="p8.m5" class="ltx_Math" alttext="X_{\alpha}\cap A" display="inline"><semantics><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X_{\alpha}\cap A</annotation></semantics></math> is infinite, we just
set <math id="p8.m6" class="ltx_Math" alttext="X_{\alpha+1}=X_{\alpha}\cap A" display="inline"><semantics><mrow><msub><mi>X</mi><mrow><mi>α</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∩</mo><mi>A</mi></mrow></mrow><annotation encoding="application/x-tex">X_{\alpha+1}=X_{\alpha}\cap A</annotation></semantics></math>. Otherwise, since
<math id="p8.m7" class="ltx_Math" alttext="X_{\alpha}=\cup_{A\in\mathcal{A}_{\alpha}}(X_{\alpha}\cap A)" display="inline"><semantics><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>=</mo><mrow><msub><mo>∪</mo><mrow><mi>A</mi><mo>∈</mo><msub><mi class="ltx_font_mathcaligraphic">𝒜</mi><mi>α</mi></msub></mrow></msub><mrow><mo stretchy="false">(</mo><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∩</mo><mi>A</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">X_{\alpha}=\cup_{A\in\mathcal{A}_{\alpha}}(X_{\alpha}\cap A)</annotation></semantics></math> is infinite,
<math id="p8.m8" class="ltx_Math" alttext="X_{\alpha}\cap A" display="inline"><semantics><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X_{\alpha}\cap A</annotation></semantics></math> is nonempty for infinitely many <math id="p8.m9" class="ltx_Math" alttext="A\in\mathcal{A}_{\alpha}" display="inline"><semantics><mrow><mi>A</mi><mo>∈</mo><msub><mi class="ltx_font_mathcaligraphic">𝒜</mi><mi>α</mi></msub></mrow><annotation encoding="application/x-tex">A\in\mathcal{A}_{\alpha}</annotation></semantics></math>.
Pick one element from each nonempty set to form the set <math id="p8.m10" class="ltx_Math" alttext="X_{\alpha+1}" display="inline"><semantics><msub><mi>X</mi><mrow><mi>α</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">X_{\alpha+1}</annotation></semantics></math>.
By definition, <math id="p8.m11" class="ltx_Math" alttext="\forall A\in\mathcal{A}_{\alpha},\left|X_{\alpha+1}\cap A\right|\leq 1" display="inline"><semantics><mrow><mrow><mrow><mo>∀</mo><mi>A</mi></mrow><mo>∈</mo><msub><mi class="ltx_font_mathcaligraphic">𝒜</mi><mi>α</mi></msub></mrow><mo>,</mo><mrow><mrow><mo>|</mo><mrow><msub><mi>X</mi><mrow><mi>α</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>∩</mo><mi>A</mi></mrow><mo>|</mo></mrow><mo>≤</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">\forall A\in\mathcal{A}_{\alpha},\left|X_{\alpha+1}\cap A\right|\leq 1</annotation></semantics></math>.
Now we consider the case <math id="p8.m12" class="ltx_Math" alttext="\alpha&lt;\omega_{1}" display="inline"><semantics><mrow><mi>α</mi><mo>&lt;</mo><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\alpha&lt;\omega_{1}</annotation></semantics></math> limit. Let
<math id="p8.m13" class="ltx_Math" alttext="\beta_{1}&lt;\beta_{2}&lt;...\beta_{n}&lt;..." display="inline"><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>β</mi><mn>2</mn></msub><mo>&lt;</mo><mrow><mi mathvariant="normal">…</mi><mo>⁢</mo><msub><mi>β</mi><mi>n</mi></msub></mrow><mo>&lt;</mo><mi mathvariant="normal">…</mi></mrow><annotation encoding="application/x-tex">\beta_{1}&lt;\beta_{2}&lt;...\beta_{n}&lt;...</annotation></semantics></math> be a cofinal <math id="p8.m14" class="ltx_Math" alttext="\omega" display="inline"><semantics><mi>ω</mi><annotation encoding="application/x-tex">\omega</annotation></semantics></math>-sequence in
<math id="p8.m15" class="ltx_Math" alttext="\alpha" display="inline"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>. Note that it is the only place where we use the continuum
hypothesis! For each <math id="p8.m16" class="ltx_Math" alttext="n&lt;\omega" display="inline"><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>ω</mi></mrow><annotation encoding="application/x-tex">n&lt;\omega</annotation></semantics></math>, we define
<math id="p8.m17" class="ltx_Math" alttext="Y_{n}=\bigcap_{i&lt;n}X_{\beta_{i}}" display="inline"><semantics><mrow><msub><mi>Y</mi><mi>n</mi></msub><mo>=</mo><mrow><msub><mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo><mrow><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow></msub><msub><mi>X</mi><msub><mi>β</mi><mi>i</mi></msub></msub></mrow></mrow><annotation encoding="application/x-tex">Y_{n}=\bigcap_{i&lt;n}X_{\beta_{i}}</annotation></semantics></math>. We have <math id="p8.m18" class="ltx_Math" alttext="X_{\beta_{n}}" display="inline"><semantics><msub><mi>X</mi><msub><mi>β</mi><mi>n</mi></msub></msub><annotation encoding="application/x-tex">X_{\beta_{n}}</annotation></semantics></math> infinite and
<math id="p8.m19" class="ltx_Math" alttext="X_{\beta_{n}}\setminus X_{\beta_{n-1}}" display="inline"><semantics><mrow><msub><mi>X</mi><msub><mi>β</mi><mi>n</mi></msub></msub><mo>∖</mo><msub><mi>X</mi><msub><mi>β</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></msub></mrow><annotation encoding="application/x-tex">X_{\beta_{n}}\setminus X_{\beta_{n-1}}</annotation></semantics></math> finite so <math id="p8.m20" class="ltx_Math" alttext="X_{\beta_{n}}\cap X_{\beta_{n-1}}" display="inline"><semantics><mrow><msub><mi>X</mi><msub><mi>β</mi><mi>n</mi></msub></msub><mo>∩</mo><msub><mi>X</mi><msub><mi>β</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></msub></mrow><annotation encoding="application/x-tex">X_{\beta_{n}}\cap X_{\beta_{n-1}}</annotation></semantics></math>
is infinite. Similarly, <math id="p8.m21" class="ltx_Math" alttext="X_{\beta_{n}}\setminus X_{\beta_{n-1}}" display="inline"><semantics><mrow><msub><mi>X</mi><msub><mi>β</mi><mi>n</mi></msub></msub><mo>∖</mo><msub><mi>X</mi><msub><mi>β</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></msub></mrow><annotation encoding="application/x-tex">X_{\beta_{n}}\setminus X_{\beta_{n-1}}</annotation></semantics></math> and
<math id="p8.m22" class="ltx_Math" alttext="X_{\beta_{n-1}}\setminus X_{\beta_{n-2}}" display="inline"><semantics><mrow><msub><mi>X</mi><msub><mi>β</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></msub><mo>∖</mo><msub><mi>X</mi><msub><mi>β</mi><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub></msub></mrow><annotation encoding="application/x-tex">X_{\beta_{n-1}}\setminus X_{\beta_{n-2}}</annotation></semantics></math> are finite so
<math id="p8.m23" class="ltx_Math" alttext="X_{\beta_{n}}\cap X_{\beta_{n-1}}\cap X_{\beta_{n-2}}" display="inline"><semantics><mrow><msub><mi>X</mi><msub><mi>β</mi><mi>n</mi></msub></msub><mo>∩</mo><msub><mi>X</mi><msub><mi>β</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></msub><mo>∩</mo><msub><mi>X</mi><msub><mi>β</mi><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub></msub></mrow><annotation encoding="application/x-tex">X_{\beta_{n}}\cap X_{\beta_{n-1}}\cap X_{\beta_{n-2}}</annotation></semantics></math> is infinite etc and finally
<math id="p8.m24" class="ltx_Math" alttext="Y_{n}" display="inline"><semantics><msub><mi>Y</mi><mi>n</mi></msub><annotation encoding="application/x-tex">Y_{n}</annotation></semantics></math> is infinite. Thus we can use a classical technique from Cantor (I can’t
find a reference) and construct the set <math id="p8.m25" class="ltx_Math" alttext="X_{\alpha}=\{x_{n}|n&lt;\omega\}" display="inline"><semantics><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>=</mo><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">|</mo><mrow><mi>n</mi><mo>&lt;</mo><mi>ω</mi></mrow><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">X_{\alpha}=\{x_{n}|n&lt;\omega\}</annotation></semantics></math>
by picking each <math id="p8.m26" class="ltx_Math" alttext="x_{n}\in Y_{n}\setminus\{x_{0},x_{1},...,x_{n-1}\}" display="inline"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>∈</mo><mrow><msub><mi>Y</mi><mi>n</mi></msub><mo>∖</mo><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">}</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">x_{n}\in Y_{n}\setminus\{x_{0},x_{1},...,x_{n-1}\}</annotation></semantics></math>
so that <math id="p8.m27" class="ltx_Math" alttext="X_{\alpha}\setminus X_{\beta_{n}}\subseteq\{x_{0},x_{1},...,x_{n-1}\}" display="inline"><semantics><mrow><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><msub><mi>X</mi><msub><mi>β</mi><mi>n</mi></msub></msub></mrow><mo>⊆</mo><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">X_{\alpha}\setminus X_{\beta_{n}}\subseteq\{x_{0},x_{1},...,x_{n-1}\}</annotation></semantics></math> is finite. Moreover
for each <math id="p8.m28" class="ltx_Math" alttext="\beta&lt;\alpha" display="inline"><semantics><mrow><mi>β</mi><mo>&lt;</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta&lt;\alpha</annotation></semantics></math> consider some <math id="p8.m29" class="ltx_Math" alttext="\beta_{n}&gt;\beta" display="inline"><semantics><mrow><msub><mi>β</mi><mi>n</mi></msub><mo>&gt;</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta_{n}&gt;\beta</annotation></semantics></math>:
<math id="p8.m30" class="ltx_Math" alttext="|X_{\alpha}\setminus X_{\beta}|\leq{|X_{\alpha}\setminus X_{\beta}|}+{|X_{%
\beta}\setminus X_{\beta_{n}}|}" display="inline"><semantics><mrow><mrow><mo stretchy="false">|</mo><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><msub><mi>X</mi><mi>β</mi></msub></mrow><mo stretchy="false">|</mo></mrow><mo>≤</mo><mrow><mrow><mo stretchy="false">|</mo><mrow><msub><mi>X</mi><mi>α</mi></msub><mo>∖</mo><msub><mi>X</mi><mi>β</mi></msub></mrow><mo stretchy="false">|</mo></mrow><mo>+</mo><mrow><mo stretchy="false">|</mo><mrow><msub><mi>X</mi><mi>β</mi></msub><mo>∖</mo><msub><mi>X</mi><msub><mi>β</mi><mi>n</mi></msub></msub></mrow><mo stretchy="false">|</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">|X_{\alpha}\setminus X_{\beta}|\leq{|X_{\alpha}\setminus X_{\beta}|}+{|X_{%
\beta}\setminus X_{\beta_{n}}|}</annotation></semantics></math> is
finite.</p>
</div>
<div id="p9" class="ltx_para">
<p class="ltx_p">The second part of the chapter is about <a href="https://en.wikipedia.org/wiki/Boolean_algebra" title="" class="ltx_ref">Boolean algebras</a>. A Boolean algebra <math id="p9.m1" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> is a completion of
a Boolean algebra <math id="p9.m2" class="ltx_Math" alttext="B" display="inline"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> if it is complete (every subset <math id="p9.m3" class="ltx_Math" alttext="X\subseteq C" display="inline"><semantics><mrow><mi>X</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">X\subseteq C</annotation></semantics></math> has
a least upper bound <math id="p9.m4" class="ltx_Math" alttext="\sum X" display="inline"><semantics><mrow><mo largeop="true" symmetric="true">∑</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\sum X</annotation></semantics></math>) and if <math id="p9.m5" class="ltx_Math" alttext="B" display="inline"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> is a dense subalgebra of <math id="p9.m6" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> (for
any <math id="p9.m7" class="ltx_Math" alttext="0&lt;c\in C" display="inline"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>c</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">0&lt;c\in C</annotation></semantics></math> there exists <math id="p9.m8" class="ltx_Math" alttext="b\in B" display="inline"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b\in B</annotation></semantics></math> such that <math id="p9.m9" class="ltx_Math" alttext="0&lt;b\leq c" display="inline"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">0&lt;b\leq c</annotation></semantics></math>).
I got stuck on the apparently easy proof of the following lemma:</p>
</div>
<div id="Thmlemma1" class="ltx_theorem ltx_theorem_lemma">
<h6 class="ltx_title ltx_runin ltx_font_bold ltx_title_theorem">
<span class="ltx_tag ltx_tag_theorem">Lemma 1</span>.</h6>
<div id="Thmlemma1.p1" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">The completion of a Boolean algebra <math id="Thmlemma1.p1.m1" class="ltx_Math" alttext="B" display="inline"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> is unique up to isomorphism</span></p>
</div>
</div>
<div class="ltx_proof">
<h6 class="ltx_title ltx_runin ltx_font_italic ltx_title_proof">Proof.</h6>
<div id="p10" class="ltx_para">
<p class="ltx_p">Let <math id="p10.m1" class="ltx_Math" alttext="C,D" display="inline"><semantics><mrow><mi>C</mi><mo>,</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C,D</annotation></semantics></math> are two completions of <math id="p10.m2" class="ltx_Math" alttext="B" display="inline"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>. It is indicated in the book
that the density of <math id="p10.m3" class="ltx_Math" alttext="B" display="inline"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> in <math id="p10.m4" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math id="p10.m5" class="ltx_Math" alttext="D" display="inline"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> is used to prove that
<math id="p10.m6" class="ltx_Math" alttext="\pi(c)=\sum^{D}\{u\in B|u\leq c\}" display="inline"><semantics><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mo largeop="true" symmetric="true">∑</mo><mi>D</mi></msup><mrow><mo stretchy="false">{</mo><mrow><mi>u</mi><mo>∈</mo><mi>B</mi></mrow><mo stretchy="false">|</mo><mrow><mi>u</mi><mo>≤</mo><mi>c</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">\pi(c)=\sum^{D}\{u\in B|u\leq c\}</annotation></semantics></math>
defines an isomorphism between <math id="p10.m7" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math id="p10.m8" class="ltx_Math" alttext="D" display="inline"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>. The example of
<math id="p10.m9" class="ltx_Math" alttext="c\neq 0\implies\pi(c)\neq 0" display="inline"><semantics><mrow><mi>c</mi><mo>≠</mo><mn>0</mn><mo>⟹</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c\neq 0\implies\pi(c)\neq 0</annotation></semantics></math> is given: indeed if <math id="p10.m10" class="ltx_Math" alttext="0&lt;c" display="inline"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">0&lt;c</annotation></semantics></math> we can
find an element <math id="p10.m11" class="ltx_Math" alttext="b\in B" display="inline"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b\in B</annotation></semantics></math> such that
<math id="p10.m12" class="ltx_Math" alttext="0&lt;b\leq c" display="inline"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">0&lt;b\leq c</annotation></semantics></math> and so <math id="p10.m13" class="ltx_Math" alttext="0&lt;b\leq\pi(c)" display="inline"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>b</mi><mo>≤</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">0&lt;b\leq\pi(c)</annotation></semantics></math>.
∎</p>
</div>
</div>
<div id="p11" class="ltx_para">
<p class="ltx_p">Two or three pages before, it is mentioned that "if <math id="p11.m1" class="ltx_Math" alttext="\pi:C\rightarrow D" display="inline"><semantics><mrow><mi>π</mi><mo>:</mo><mrow><mi>C</mi><mo>→</mo><mi>D</mi></mrow></mrow><annotation encoding="application/x-tex">\pi:C\rightarrow D</annotation></semantics></math>
is a one-to-one mapping such that
<math id="p11.m2" class="ltx_Math" alttext="\forall u,v\in C,u\leq v\Leftrightarrow\pi(u)\leq\pi(v)" display="inline"><semantics><mrow><mo>∀</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>∈</mo><mi>C</mi><mo>,</mo><mi>u</mi><mo>≤</mo><mi>v</mi><mo>⇔</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><mo>≤</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\forall u,v\in C,u\leq v\Leftrightarrow\pi(u)\leq\pi(v)</annotation></semantics></math> then
<math id="p11.m3" class="ltx_Math" alttext="\pi" display="inline"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is an isomorphism".
That seems to be the most natural method to prove the lemma above. However,
this statement is false: consider the morphism of Boolean algebra
<math id="p11.m4" class="ltx_Math" alttext="\pi:\{0,1\}\rightarrow\operatorname{\mathcal{P}}(\{0,1\})" display="inline"><semantics><mrow><mi>π</mi><mo>:</mo><mrow><mrow><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><mo>→</mo><mrow><mo class="ltx_font_mathcaligraphic">𝒫</mo><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">\pi:\{0,1\}\rightarrow\operatorname{\mathcal{P}}(\{0,1\})</annotation></semantics></math> which is one-to-one but
not surjective. Actually, the property
<math id="p11.m5" class="ltx_Math" alttext="\forall u,v\in C,u\leq v\Leftrightarrow\pi(u)\leq\pi(v)" display="inline"><semantics><mrow><mo>∀</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>∈</mo><mi>C</mi><mo>,</mo><mi>u</mi><mo>≤</mo><mi>v</mi><mo>⇔</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><mo>≤</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\forall u,v\in C,u\leq v\Leftrightarrow\pi(u)\leq\pi(v)</annotation></semantics></math> implies
the fact that <math id="p11.m6" class="ltx_Math" alttext="\pi" display="inline"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is one-to-one, which becomes vacuous.
So I suspect the author
rather means "surjective" instead of "one-to-one". Indeed, in that case
<math id="p11.m7" class="ltx_Math" alttext="\pi" display="inline"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is a bijection that preserves the order <math id="p11.m8" class="ltx_Math" alttext="\leq" display="inline"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\leq</annotation></semantics></math> in both directions
and since all the
operations of the Boolean algebra can be described in terms of this order,
<math id="p11.m9" class="ltx_Math" alttext="\pi" display="inline"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is an isomorphism.</p>
</div>
<div id="p12" class="ltx_para">
<p class="ltx_p">So first, given <math id="p12.m1" class="ltx_Math" alttext="d\in D" display="inline"><semantics><mrow><mi>d</mi><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">d\in D</annotation></semantics></math>, we want to find <math id="p12.m2" class="ltx_Math" alttext="c\in C" display="inline"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">c\in C</annotation></semantics></math> such that <math id="p12.m3" class="ltx_Math" alttext="\pi(c)=d" display="inline"><semantics><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">\pi(c)=d</annotation></semantics></math>.
By symmetry, the natural candidate is <math id="p12.m4" class="ltx_Math" alttext="c=\sum^{C}\{u\in B|u\leq d\}" display="inline"><semantics><mrow><mi>c</mi><mo>=</mo><mrow><msup><mo largeop="true" symmetric="true">∑</mo><mi>C</mi></msup><mrow><mo stretchy="false">{</mo><mrow><mi>u</mi><mo>∈</mo><mi>B</mi></mrow><mo stretchy="false">|</mo><mrow><mi>u</mi><mo>≤</mo><mi>d</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">c=\sum^{C}\{u\in B|u\leq d\}</annotation></semantics></math>.
For all <math id="p12.m5" class="ltx_Math" alttext="u\leq d" display="inline"><semantics><mrow><mi>u</mi><mo>≤</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">u\leq d</annotation></semantics></math>, we have <math id="p12.m6" class="ltx_Math" alttext="u\leq c" display="inline"><semantics><mrow><mi>u</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">u\leq c</annotation></semantics></math> and so
<math id="p12.m7" class="ltx_Math" alttext="d\leq\sum^{D}\{u\in B|u\leq d\}\leq\sum^{D}\{u\in B|u\leq c\}=\pi(c)" display="inline"><semantics><mrow><mi>d</mi><mo>≤</mo><mrow><msup><mo largeop="true" symmetric="true">∑</mo><mi>D</mi></msup><mrow><mo stretchy="false">{</mo><mrow><mi>u</mi><mo>∈</mo><mi>B</mi></mrow><mo stretchy="false">|</mo><mrow><mi>u</mi><mo>≤</mo><mi>d</mi></mrow><mo stretchy="false">}</mo></mrow></mrow><mo>≤</mo><mrow><msup><mo largeop="true" symmetric="true">∑</mo><mi>D</mi></msup><mrow><mo stretchy="false">{</mo><mrow><mi>u</mi><mo>∈</mo><mi>B</mi></mrow><mo stretchy="false">|</mo><mrow><mi>u</mi><mo>≤</mo><mi>c</mi></mrow><mo stretchy="false">}</mo></mrow></mrow><mo>=</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">d\leq\sum^{D}\{u\in B|u\leq d\}\leq\sum^{D}\{u\in B|u\leq c\}=\pi(c)</annotation></semantics></math>. If <math id="p12.m8" class="ltx_Math" alttext="d&lt;\pi(c)" display="inline"><semantics><mrow><mi>d</mi><mo>&lt;</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">d&lt;\pi(c)</annotation></semantics></math> then by density
we can find <math id="p12.m9" class="ltx_Math" alttext="b\in B" display="inline"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b\in B</annotation></semantics></math> such that <math id="p12.m10" class="ltx_Math" alttext="0&lt;b\leq\pi(c)-d" display="inline"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>b</mi><mo>≤</mo><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow><mo>-</mo><mi>d</mi></mrow></mrow><annotation encoding="application/x-tex">0&lt;b\leq\pi(c)-d</annotation></semantics></math>. Hence
<math id="p12.m11" class="ltx_Math" alttext="b\leq\pi(c)" display="inline"><semantics><mrow><mi>b</mi><mo>≤</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">b\leq\pi(c)</annotation></semantics></math> and <math id="p12.m12" class="ltx_Math" alttext="b\leq-d" display="inline"><semantics><mrow><mi>b</mi><mo>≤</mo><mrow><mo>-</mo><mi>d</mi></mrow></mrow><annotation encoding="application/x-tex">b\leq-d</annotation></semantics></math>. The latter implies that for all <math id="p12.m13" class="ltx_Math" alttext="u\leq d" display="inline"><semantics><mrow><mi>u</mi><mo>≤</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">u\leq d</annotation></semantics></math>
we have <math id="p12.m14" class="ltx_Math" alttext="u\leq-b" display="inline"><semantics><mrow><mi>u</mi><mo>≤</mo><mrow><mo>-</mo><mi>b</mi></mrow></mrow><annotation encoding="application/x-tex">u\leq-b</annotation></semantics></math> an so <math id="p12.m15" class="ltx_Math" alttext="\pi(c)\leq-b" display="inline"><semantics><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow><mo>≤</mo><mrow><mo>-</mo><mi>b</mi></mrow></mrow><annotation encoding="application/x-tex">\pi(c)\leq-b</annotation></semantics></math>. Combining this with the former,
we would have <math id="p12.m16" class="ltx_Math" alttext="b\leq\pi(c)\cdot-\pi(c)=0" display="inline"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><mo>⋅</mo><mo>-</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b\leq\pi(c)\cdot-\pi(c)=0</annotation></semantics></math>. Thus <math id="p12.m17" class="ltx_Math" alttext="\pi" display="inline"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is surjective.</p>
</div>
<div id="p13" class="ltx_para">
<p class="ltx_p">It remains to prove
<math id="p13.m1" class="ltx_Math" alttext="\forall u,v\in C,u\leq v\Leftrightarrow\pi(u)\leq\pi(v)" display="inline"><semantics><mrow><mo>∀</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>∈</mo><mi>C</mi><mo>,</mo><mi>u</mi><mo>≤</mo><mi>v</mi><mo>⇔</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><mo>≤</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\forall u,v\in C,u\leq v\Leftrightarrow\pi(u)\leq\pi(v)</annotation></semantics></math>. If
<math id="p13.m2" class="ltx_Math" alttext="u\leq v" display="inline"><semantics><mrow><mi>u</mi><mo>≤</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u\leq v</annotation></semantics></math> then <math id="p13.m3" class="ltx_Math" alttext="\pi(u)=\sum^{D}\{b\in B|b\leq u\}\leq\sum^{D}\{b\in B|b\leq v\}\leq\pi(v)" display="inline"><semantics><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mo largeop="true" symmetric="true">∑</mo><mi>D</mi></msup><mrow><mo stretchy="false">{</mo><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><mo stretchy="false">|</mo><mrow><mi>b</mi><mo>≤</mo><mi>u</mi></mrow><mo stretchy="false">}</mo></mrow></mrow><mo>≤</mo><mrow><msup><mo largeop="true" symmetric="true">∑</mo><mi>D</mi></msup><mrow><mo stretchy="false">{</mo><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><mo stretchy="false">|</mo><mrow><mi>b</mi><mo>≤</mo><mi>v</mi></mrow><mo stretchy="false">}</mo></mrow></mrow><mo>≤</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">\pi(u)=\sum^{D}\{b\in B|b\leq u\}\leq\sum^{D}\{b\in B|b\leq v\}\leq\pi(v)</annotation></semantics></math>. Let’s consider the
contrapositive of the converse implication: suppose <math id="p13.m4" class="ltx_Math" alttext="u\nleq v" display="inline"><semantics><mrow><mi>u</mi><mo>≰</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u\nleq v</annotation></semantics></math>.
Then <math id="p13.m5" class="ltx_Math" alttext="u\cdot-v\neq 0" display="inline"><semantics><mrow><mi>u</mi><mo>⋅</mo><mo>-</mo><mi>v</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">u\cdot-v\neq 0</annotation></semantics></math> and <math id="p13.m6" class="ltx_Math" alttext="0&lt;\pi(u\cdot-v)" display="inline"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>u</mi><mo>⋅</mo><mo>-</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">0&lt;\pi(u\cdot-v)</annotation></semantics></math>
(we use the hint given in the book). If we are able to prove
<math id="p13.m7" class="ltx_Math" alttext="\pi(u\cdot-v)\leq\pi(u)\cdot-\pi(v)" display="inline"><semantics><mrow><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>u</mi><mo>⋅</mo><mo>-</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><mo>≤</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><mo>⋅</mo><mo>-</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi(u\cdot-v)\leq\pi(u)\cdot-\pi(v)</annotation></semantics></math> then we would have
<math id="p13.m8" class="ltx_Math" alttext="0&lt;\pi(u)\cdot-\pi(v)" display="inline"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><mo>⋅</mo><mo>-</mo><mi>π</mi><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">0&lt;\pi(u)\cdot-\pi(v)</annotation></semantics></math> and so
<math id="p13.m9" class="ltx_Math" alttext="\pi(u)\nleq\pi(v)" display="inline"><semantics><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></mrow><mo>≰</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">\pi(u)\nleq\pi(v)</annotation></semantics></math> as desired. It suffices to show two inequalities on
the <math id="p13.m10" class="ltx_Math" alttext="\cdot" display="inline"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> and <math id="p13.m11" class="ltx_Math" alttext="-" display="inline"><semantics><mo>-</mo><annotation encoding="application/x-tex">-</annotation></semantics></math> operations.
Note that <math id="p13.m12" class="ltx_Math" alttext="\forall b\in B,\pi(b)=b" display="inline"><semantics><mrow><mrow><mrow><mo>∀</mo><mi>b</mi></mrow><mo>∈</mo><mi>B</mi></mrow><mo>,</mo><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>b</mi></mrow></mrow><annotation encoding="application/x-tex">\forall b\in B,\pi(b)=b</annotation></semantics></math>. Let <math id="p13.m13" class="ltx_Math" alttext="w\in C" display="inline"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">w\in C</annotation></semantics></math>.
Let <math id="p13.m14" class="ltx_Math" alttext="w_{1},w_{2}\in C" display="inline"><semantics><mrow><mrow><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><msub><mi>w</mi><mn>2</mn></msub></mrow><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">w_{1},w_{2}\in C</annotation></semantics></math>. Then for all <math id="p13.m15" class="ltx_Math" alttext="b\in B" display="inline"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b\in B</annotation></semantics></math>, <math id="p13.m16" class="ltx_Math" alttext="b\leq w_{1}\cdot w_{2}\implies b\leq w_{1},w_{2}\implies b=\pi(b)\leq\pi(w_{1}%
),\pi(w_{1})\implies b\leq\pi(w_{1})\cdot\pi(w_{2})" display="inline"><semantics><mrow><mrow><mi>b</mi><mo>≤</mo><mrow><msub><mi>w</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>w</mi><mn>2</mn></msub></mrow><mo>⟹</mo><mi>b</mi><mo>≤</mo><msub><mi>w</mi><mn>1</mn></msub></mrow><mo>,</mo><mrow><msub><mi>w</mi><mn>2</mn></msub><mo>⟹</mo><mi>b</mi><mo>=</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow><mo>≤</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>⟹</mo><mi>b</mi><mo>≤</mo><mrow><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>⋅</mo><mi>π</mi></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">b\leq w_{1}\cdot w_{2}\implies b\leq w_{1},w_{2}\implies b=\pi(b)\leq\pi(w_{1}%
),\pi(w_{1})\implies b\leq\pi(w_{1})\cdot\pi(w_{2})</annotation></semantics></math> so
<math id="p13.m17" class="ltx_Math" alttext="\pi(w_{1}\cdot w_{2})\leq\pi(w_{1})\cdot\pi(w_{2})" display="inline"><semantics><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>w</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>w</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>≤</mo><mrow><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>⋅</mo><mi>π</mi></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">\pi(w_{1}\cdot w_{2})\leq\pi(w_{1})\cdot\pi(w_{2})</annotation></semantics></math>. Similarly, we have
for all <math id="p13.m18" class="ltx_Math" alttext="b\in B" display="inline"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b\in B</annotation></semantics></math>,
<math id="p13.m19" class="ltx_Math" alttext="b\leq-w\implies-b\geq w\implies-b=\pi(-b)\geq\pi(w)\implies b\leq-\pi(w)" display="inline"><semantics><mrow><mi>b</mi><mo>≤</mo><mrow><mo>-</mo><mi>w</mi></mrow><mo>⟹</mo><mrow><mo>-</mo><mi>b</mi></mrow><mo>≥</mo><mi>w</mi><mo>⟹</mo><mrow><mo>-</mo><mi>b</mi></mrow><mo>=</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo>-</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>≥</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow><mo>⟹</mo><mi>b</mi><mo>≤</mo><mrow><mo>-</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">b\leq-w\implies-b\geq w\implies-b=\pi(-b)\geq\pi(w)\implies b\leq-\pi(w)</annotation></semantics></math>. So <math id="p13.m20" class="ltx_Math" alttext="\pi(-w)\leq-\pi(w)" display="inline"><semantics><mrow><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo>-</mo><mi>w</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>≤</mo><mrow><mo>-</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">\pi(-w)\leq-\pi(w)</annotation></semantics></math>.</p>
</div>
<div id="p14" class="ltx_para">
<p class="ltx_p">As a conclusion, I notice a similarity between these too cases: both have
a sketchy proof based on a statement that seems incorrect ("<math id="p14.m1" class="ltx_Math" alttext="D" display="inline"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> is a filter",
"any one-to-one mapping between Boolean algebra that preserves the order
<math id="p14.m2" class="ltx_Math" alttext="\leq" display="inline"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\leq</annotation></semantics></math> in both directions is an isomorphism"). Sometimes, I’m wondering if
these kinds of inaccuracy are not intentional in order to force readers to
try and find the proof themselves :-)</p>
</div>


{% endraw %}
