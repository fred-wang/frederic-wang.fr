---
layout: post
title: "Analysis of Lithium's algorithm"
tags: cs mozilla
---

{% raw %}

  
<div id="p1" class="ltx_para">
<p class="ltx_p">I’ve recently been working on automated testcase reduction tools and thus
I had the chance to study <a href="http://www.squarefree.com" title="" class="ltx_ref">Jesse Ruderman</a>’s
<a href="http://www.squarefree.com/2007/09/15/introducing-lithium-a-testcase-reduction-tool/" title="" class="ltx_ref">Lithium</a> tool, itself inspired from the
<a href="http://www.st.cs.uni-saarland.de/papers/tse2002/" title="" class="ltx_ref">ddmin</a> algorithm. This
paper contains good ideas, like for example the fact that the reduction could
be improved if we rely on the testcase structure like XML nodes or grammar
tokens
instead of just characters/lines. However, the authors of the
ddmin paper really don’t analyse precisely the complexity of the algorithm,
except the best and worst case and there is a large gap between the two.
<a href="http://www.squarefree.com/lithium/algorithm.html" title="" class="ltx_ref">Jesse’s analysis</a> is
much better and in particular introduces the concepts of monotonic testcase
and clustered reduction where the algorithm performs the best and which
intuitively seems the usual testcases that we meet in practice. However, the
monotonic+clustered case complexity is only “guessed” and the bound
<math id="p1.m1" class="ltx_Math" alttext="O(M\log_{2}(N))" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(M\log_{2}(N))</annotation></semantics></math> for a monotonic testcase (of size <math id="p1.m2" class="ltx_Math" alttext="N" display="inline"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> with final reduction of
size <math id="p1.m3" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>) is not optimal. For example if the final reduction is relatively
small compared to <math id="p1.m4" class="ltx_Math" alttext="N" display="inline"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>, say
<math id="p1.m5" class="ltx_Math" alttext="M=\frac{N}{\log_{2}(N)}=o(N)" display="inline"><semantics><mrow><mi>M</mi><mo>=</mo><mfrac><mi>N</mi><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mfrac><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">M=\frac{N}{\log_{2}(N)}=o(N)</annotation></semantics></math> then <math id="p1.m6" class="ltx_Math" alttext="M\log_{2}(N)=N=\Omega(N)" display="inline"><semantics><mrow><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mi>N</mi><mo>=</mo><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">M\log_{2}(N)=N=\Omega(N)</annotation></semantics></math> and we
can’t say that the number of verifications is small compared to <math id="p1.m7" class="ltx_Math" alttext="N" display="inline"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>.
In particular, Jesse can
not deduce from his bound that Lithium’s algorithm is better than an approach
based on <math id="p1.m8" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> binary search executions!
In this blog post, I shall give the optimal bound for
the monotonic case and formalize that in some sense the clustered reduction is
near the best case. I’ll also compare Lithium’s algorithm with the binary search
approach and with the ddmin algorithm. I shall explain that Lithium is the
best in the monotonic case (or actually matches the ddmin in that case).</p>
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p">Thus suppose that we are given a large testcase exhibiting an unwanted behavior.
We want to find a smaller test case exhibiting the same behavior
and one way is to isolate subtestcases that can not be reduced any further.
A testcase can be quite general so here are basic definitions to formalize a bit
the problem:
</p>
</div>
<div id="p3" class="ltx_para">
<ul id="Ch0.I1" class="ltx_itemize">
<li id="Ch0.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="Ch0.I1.i1.p1" class="ltx_para">
<p class="ltx_p">A <span class="ltx_text ltx_font_italic">testcase</span> <math id="Ch0.I1.i1.p1.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is a nonempty finite sets of elements
(lines, characters, tree nodes, user actions) exhibiting an “interesting”
behavior (crash, hang and other bugs…)</p>
</div>
</li>
<li id="Ch0.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="Ch0.I1.i2.p1" class="ltx_para">
<p class="ltx_p">A <span class="ltx_text ltx_font_italic">reduction</span> <math id="Ch0.I1.i2.p1.m1" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> of <math id="Ch0.I1.i2.p1.m2" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is a testcase <math id="Ch0.I1.i2.p1.m3" class="ltx_Math" alttext="T\subseteq S" display="inline"><semantics><mrow><mi>T</mi><mo>⊆</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">T\subseteq S</annotation></semantics></math>
with the same “interesting” behavior as <math id="Ch0.I1.i2.p1.m4" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p>
</div>
</li>
<li id="Ch0.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="Ch0.I1.i3.p1" class="ltx_para">
<p class="ltx_p">A testcase <math id="Ch0.I1.i3.p1.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is <span class="ltx_text ltx_font_italic">minimal</span> if
<math id="Ch0.I1.i3.p1.m2" class="ltx_Math" alttext="\forall T\subsetneq S,T\text{ is not a reduction of }S" display="inline"><semantics><mrow><mrow><mo>∀</mo><mi>T</mi></mrow><mo>⊊</mo><mrow><mi>S</mi><mo>,</mo><mrow><mi>T</mi><mo>⁢</mo><mtext> is not a reduction of </mtext><mo>⁢</mo><mi>S</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">\forall T\subsetneq S,T\text{ is not a reduction of }S</annotation></semantics></math>.</p>
</div>
</li>
</ul>
</div>
<div id="p4" class="ltx_para">
<p class="ltx_p">Note that by definition, <math id="p4.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is a reduction of itself and <math id="p4.m2" class="ltx_Math" alttext="\emptyset" display="inline"><semantics><mi mathvariant="normal">∅</mi><annotation encoding="application/x-tex">\emptyset</annotation></semantics></math> is not
a reduction of <math id="p4.m3" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>. Also the relation “is a reduction of” is transitive that
is a reduction of a reduction of <math id="p4.m4" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is a reduction of <math id="p4.m5" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p>
</div>
<div id="p5" class="ltx_para">
<p class="ltx_p">We assume that verifying one subset to check if it has the
“interesting” behavior is what takes the most time
(think e.g. testing a hang or user actions) so we want to optimize the number
of testcases verified. Moreover, the original testcase <math id="p5.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is large and so a
fast reduction algorithm would be to have a complexity in <math id="p5.m2" class="ltx_Math" alttext="o(|S|)" display="inline"><semantics><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">o(|S|)</annotation></semantics></math>.
Of course, we also expect to find a small reduction
<math id="p5.m3" class="ltx_Math" alttext="T\subseteq S" display="inline"><semantics><mrow><mi>T</mi><mo>⊆</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">T\subseteq S</annotation></semantics></math> that is <math id="p5.m4" class="ltx_Math" alttext="|T|=o(|S|)" display="inline"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>T</mi><mo stretchy="false">|</mo></mrow><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">|T|=o(|S|)</annotation></semantics></math>.</p>
</div>
<div id="p6" class="ltx_para">
<p class="ltx_p">Without information on the structure on a given testcase <math id="p6.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> or on the
properties of the reduction <math id="p6.m2" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>, we must consider
the <math id="p6.m3" class="ltx_Math" alttext="2^{|S|}-2" display="inline"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow></msup><mo>-</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{|S|}-2</annotation></semantics></math> subsets <math id="p6.m4" class="ltx_Math" alttext="\emptyset\neq T\neq S" display="inline"><semantics><mrow><mi mathvariant="normal">∅</mi><mo>≠</mo><mi>T</mi><mo>≠</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\emptyset\neq T\neq S</annotation></semantics></math>, to find a minimal
reduction. And we only know how to do that in
<math id="p6.m5" class="ltx_Math" alttext="O\left(2^{|S|}\right)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo>(</mo><msup><mn>2</mn><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow></msup><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(2^{|S|}\right)</annotation></semantics></math> operations (or <math id="p6.m6" class="ltx_Math" alttext="O\left(2^{|S|/2}\right)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo>(</mo><msup><mn>2</mn><mrow><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo>/</mo><mn>2</mn></mrow></msup><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(2^{|S|/2}\right)</annotation></semantics></math> with
Grover’s algorithm ;-)).
Similarly, even to determine whether <math id="p6.m7" class="ltx_Math" alttext="T\subseteq S" display="inline"><semantics><mrow><mi>T</mi><mo>⊆</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">T\subseteq S</annotation></semantics></math> is minimal would
require testing <math id="p6.m8" class="ltx_Math" alttext="2^{|T|}-2" display="inline"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy="false">|</mo><mi>T</mi><mo stretchy="false">|</mo></mrow></msup><mo>-</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{|T|}-2</annotation></semantics></math> subsets which is not necessarily <math id="p6.m9" class="ltx_Math" alttext="o(|S|)" display="inline"><semantics><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">o(|S|)</annotation></semantics></math>
(e.g. <math id="p6.m10" class="ltx_Math" alttext="|T|=\log_{2}{(|S|)}=o(|S|)" display="inline"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>T</mi><mo stretchy="false">|</mo></mrow><mo>=</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">|T|=\log_{2}{(|S|)}=o(|S|)</annotation></semantics></math>).
Hence we consider the following definitions:</p>
</div>
<div id="p7" class="ltx_para">
<ul id="Ch0.I2" class="ltx_itemize">
<li id="Ch0.I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="Ch0.I2.i1.p1" class="ltx_para">
<p class="ltx_p">For any integer <math id="Ch0.I2.i1.p1.m1" class="ltx_Math" alttext="n\geq 1" display="inline"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n\geq 1</annotation></semantics></math>, <math id="Ch0.I2.i1.p1.m2" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is <math id="Ch0.I2.i1.p1.m3" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math><span class="ltx_text ltx_font_italic">-minimal</span> if
<math id="Ch0.I2.i1.p1.m4" class="ltx_Math" alttext="\forall T\subsetneq S,|S-T|\leq n\implies T\text{ is not a reduction of }S" display="inline"><semantics><mrow><mrow><mrow><mo>∀</mo><mi>T</mi></mrow><mo>⊊</mo><mi>S</mi></mrow><mo>,</mo><mrow><mrow><mo stretchy="false">|</mo><mrow><mi>S</mi><mo>-</mo><mi>T</mi></mrow><mo stretchy="false">|</mo></mrow><mo>≤</mo><mi>n</mi><mo>⟹</mo><mrow><mi>T</mi><mo>⁢</mo><mtext> is not a reduction of </mtext><mo>⁢</mo><mi>S</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">\forall T\subsetneq S,|S-T|\leq n\implies T\text{ is not a reduction of }S</annotation></semantics></math>.</p>
</div>
</li>
<li id="Ch0.I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="Ch0.I2.i2.p1" class="ltx_para">
<p class="ltx_p">In particular, <math id="Ch0.I2.i2.p1.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is <math id="Ch0.I2.i2.p1.m2" class="ltx_Math" alttext="1" display="inline"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math><span class="ltx_text ltx_font_italic">-minimal</span> if
<math id="Ch0.I2.i2.p1.m3" class="ltx_Math" alttext="\forall x\in S,S\setminus\{x\}\text{ is not a reduction of }S" display="inline"><semantics><mrow><mrow><mo>∀</mo><mi>x</mi></mrow><mo>∈</mo><mrow><mi>S</mi><mo>,</mo><mrow><mi>S</mi><mo>∖</mo><mrow><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><mo>⁢</mo><mtext> is not a reduction of </mtext><mo>⁢</mo><mi>S</mi></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">\forall x\in S,S\setminus\{x\}\text{ is not a reduction of }S</annotation></semantics></math>.</p>
</div>
</li>
<li id="Ch0.I2.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="Ch0.I2.i3.p1" class="ltx_para">
<p class="ltx_p"><math id="Ch0.I2.i3.p1.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic if <math id="Ch0.I2.i3.p1.m2" class="ltx_Math" alttext="\forall T_{1}\subseteq T_{2}\subseteq S,\,T_{1}\text{ is a reduction of }S%
\implies T_{2}\text{ is a reduction of }S" display="inline"><semantics><mrow><mrow><mrow><mo>∀</mo><msub><mi>T</mi><mn>1</mn></msub></mrow><mo>⊆</mo><msub><mi>T</mi><mn>2</mn></msub><mo>⊆</mo><mi>S</mi></mrow><mo rspace="4.2pt">,</mo><mrow><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>⁢</mo><mtext> is a reduction of </mtext><mo>⁢</mo><mi>S</mi></mrow><mo>⟹</mo><mrow><msub><mi>T</mi><mn>2</mn></msub><mo>⁢</mo><mtext> is a reduction of </mtext><mo>⁢</mo><mi>S</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">\forall T_{1}\subseteq T_{2}\subseteq S,\,T_{1}\text{ is a reduction of }S%
\implies T_{2}\text{ is a reduction of }S</annotation></semantics></math>.</p>
</div>
</li>
</ul>
</div>
<div id="p8" class="ltx_para">
<p class="ltx_p">Finding a <math id="p8.m1" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-minimal reduction will give a minimal testcase that is no longer
interesting if we remove any portion of size at most <math id="p8.m2" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. Clearly, <math id="p8.m3" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is
minimal if it is <math id="p8.m4" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-minimal for all <math id="p8.m5" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. Moreover, <math id="p8.m6" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is always <math id="p8.m7" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-minimal
for any <math id="p8.m8" class="ltx_Math" alttext="n\geq|S|" display="inline"><semantics><mrow><mi>n</mi><mo>≥</mo><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow></mrow><annotation encoding="application/x-tex">n\geq|S|</annotation></semantics></math>. We still need to test exponentially many
subsets to find a <math id="p8.m9" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-minimal reduction. To decide whether
<math id="p8.m10" class="ltx_Math" alttext="T\subseteq S" display="inline"><semantics><mrow><mi>T</mi><mo>⊆</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">T\subseteq S</annotation></semantics></math> is <math id="p8.m11" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-minimal, we need to consider subsets obtained by
removing portions of size <math id="p8.m12" class="ltx_Math" alttext="1,2,...,\min(n,|T|-1)" display="inline"><semantics><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mrow><mi>min</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mrow><mrow><mo stretchy="false">|</mo><mi>T</mi><mo stretchy="false">|</mo></mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">1,2,...,\min(n,|T|-1)</annotation></semantics></math>
that is <math id="p8.m13" class="ltx_Math" alttext="\sum_{k=1}^{\min(n,|T|-1)}\binom{|T|}{k}" display="inline"><semantics><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>min</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mrow><mrow><mo stretchy="false">|</mo><mi>T</mi><mo stretchy="false">|</mo></mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></msubsup><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mo stretchy="false">|</mo><mi>T</mi><mo stretchy="false">|</mo></mrow><mi>k</mi></mfrac><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{k=1}^{\min(n,|T|-1)}\binom{|T|}{k}</annotation></semantics></math> subsets. In
particular whether <math id="p8.m14" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is <math id="p8.m15" class="ltx_Math" alttext="1" display="inline"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-minimal is <math id="p8.m16" class="ltx_Math" alttext="O(|T|)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">|</mo><mi>T</mi><mo stretchy="false">|</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(|T|)</annotation></semantics></math> and so <math id="p8.m17" class="ltx_Math" alttext="o(|S|)" display="inline"><semantics><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">o(|S|)</annotation></semantics></math> if
<math id="p8.m18" class="ltx_Math" alttext="T=o(|S|)" display="inline"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">T=o(|S|)</annotation></semantics></math>.
If <math id="p8.m19" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic then so is any reduction <math id="p8.m20" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> of <math id="p8.m21" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>. Moreover, if
<math id="p8.m22" class="ltx_Math" alttext="T\subsetneq S" display="inline"><semantics><mrow><mi>T</mi><mo>⊊</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">T\subsetneq S</annotation></semantics></math> is a reduction of <math id="p8.m23" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> and <math id="p8.m24" class="ltx_Math" alttext="x\in S\setminus T" display="inline"><semantics><mrow><mi>x</mi><mo>∈</mo><mrow><mi>S</mi><mo>∖</mo><mi>T</mi></mrow></mrow><annotation encoding="application/x-tex">x\in S\setminus T</annotation></semantics></math>, then
<math id="p8.m25" class="ltx_Math" alttext="T\subseteq S\setminus\{x\}\subsetneq S" display="inline"><semantics><mrow><mi>T</mi><mo>⊆</mo><mrow><mi>S</mi><mo>∖</mo><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow></mrow><mo>⊊</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">T\subseteq S\setminus\{x\}\subsetneq S</annotation></semantics></math> and so <math id="p8.m26" class="ltx_Math" alttext="S\setminus\{x\}" display="inline"><semantics><mrow><mi>S</mi><mo>∖</mo><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">S\setminus\{x\}</annotation></semantics></math>
is a reduction of <math id="p8.m27" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>. Hence when <math id="p8.m28" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic, <math id="p8.m29" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is <math id="p8.m30" class="ltx_Math" alttext="1" display="inline"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-minimal if and
only if it is minimal. We will target <math id="p8.m31" class="ltx_Math" alttext="1" display="inline"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-minimal reduction in what follows.</p>
</div>
<div id="p9" class="ltx_para">
<p class="ltx_p">Let’s consider Lithium’s algorithm.
We assume that <math id="p9.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is ordered and so can be identified with the interval
<math id="p9.m2" class="ltx_Math" alttext="[1,|S|]" display="inline"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,|S|]</annotation></semantics></math> (think for example line numbers). For simplicity, let’s first
assume that
the size of the original testcase is a power of two, that is <math id="p9.m3" class="ltx_Math" alttext="|S|=N=2^{n}" display="inline"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>S</mi><mo stretchy="false">|</mo></mrow><mo>=</mo><mi>N</mi><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">|S|=N=2^{n}</annotation></semantics></math>.
Lithium starts by <math id="p9.m4" class="ltx_Math" alttext="n-1" display="inline"><semantics><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> steps <math id="p9.m5" class="ltx_Math" alttext="k=1,2,...,n-1" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow><annotation encoding="application/x-tex">k=1,2,...,n-1</annotation></semantics></math>. At step <math id="p9.m6" class="ltx_Math" alttext="k" display="inline"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>, we consider
the chunks among the intervals
<math id="p9.m7" class="ltx_Math" alttext="[1+j2^{n-k},(j+1)2^{n-k}]\ (0\leq j&lt;2^{k})" display="inline"><semantics><mrow><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>+</mo><mi>j</mi><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mi>k</mi></mrow></msup><mo>,</mo><mrow><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mi>k</mi></mrow></msup><mo rspace="7.5pt" stretchy="false">]</mo></mrow><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">[1+j2^{n-k},(j+1)2^{n-k}]\ (0\leq j&lt;2^{k})</annotation></semantics></math> of size <math id="p9.m8" class="ltx_Math" alttext="2^{n-k}" display="inline"><semantics><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mi>k</mi></mrow></msup><annotation encoding="application/x-tex">2^{n-k}</annotation></semantics></math>.
Lithium verifies if removing each
chunk provides a reduction. If so, it permanently removes that chunk and tries
another chunk. Because <math id="p9.m9" class="ltx_Math" alttext="\emptyset" display="inline"><semantics><mi mathvariant="normal">∅</mi><annotation encoding="application/x-tex">\emptyset</annotation></semantics></math> is not a reduction of <math id="p9.m10" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>, we immediately
increment <math id="p9.m11" class="ltx_Math" alttext="k" display="inline"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> if it remains only one chunk.
The <math id="p9.m12" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-th step is the same, with chunk of size 1 but we stop
only when we are sure that the current testcase <math id="p9.m13" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is <math id="p9.m14" class="ltx_Math" alttext="1" display="inline"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-minimal that is
when after <math id="p9.m15" class="ltx_Math" alttext="|T|" display="inline"><semantics><mrow><mo stretchy="false">|</mo><mi>T</mi><mo stretchy="false">|</mo></mrow><annotation encoding="application/x-tex">|T|</annotation></semantics></math> attempts, we have not reduced <math id="p9.m16" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> any further. If <math id="p9.m17" class="ltx_Math" alttext="N" display="inline"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> is not a
power of 2 then <math id="p9.m18" class="ltx_Math" alttext="2^{n-1}&lt;N&lt;2^{n}" display="inline"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>N</mi><mo>&lt;</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n-1}&lt;N&lt;2^{n}</annotation></semantics></math> where <math id="p9.m19" class="ltx_Math" alttext="n=\lceil\log_{2}(N)\rceil" display="inline"><semantics><mrow><mi>n</mi><mo>=</mo><mrow><mo stretchy="false">⌈</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">n=\lceil\log_{2}(N)\rceil</annotation></semantics></math>.
In that case, we apply the same algorithm as <math id="p9.m20" class="ltx_Math" alttext="2^{n}" display="inline"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math> (i.e. as if there were
<math id="p9.m21" class="ltx_Math" alttext="2^{n}-N" display="inline"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">2^{n}-N</annotation></semantics></math> dummy elements at the end)
except that we don’t need to remove the chunks that are entirely in that
additional part.
This saves testing at most <math id="p9.m22" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> subtests (those that would be obtained by
removing the dummy chunks at the end of sizes <math id="p9.m23" class="ltx_Math" alttext="2^{n-1},2^{n-2},...,1" display="inline"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>,</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msup><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{n-1},2^{n-2},...,1</annotation></semantics></math>). Hence
in general if <math id="p9.m24" class="ltx_Math" alttext="C_{N}" display="inline"><semantics><msub><mi>C</mi><mi>N</mi></msub><annotation encoding="application/x-tex">C_{N}</annotation></semantics></math> is the number of
subsets of <math id="p9.m25" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> tried by Lithium, we have <math id="p9.m26" class="ltx_Math" alttext="C_{2^{n}}-n\leq C_{N}\leq C_{2^{n}}" display="inline"><semantics><mrow><mrow><msub><mi>C</mi><msup><mn>2</mn><mi>n</mi></msup></msub><mo>-</mo><mi>n</mi></mrow><mo>≤</mo><msub><mi>C</mi><mi>N</mi></msub><mo>≤</mo><msub><mi>C</mi><msup><mn>2</mn><mi>n</mi></msup></msub></mrow><annotation encoding="application/x-tex">C_{2^{n}}-n\leq C_{N}\leq C_{2^{n}}</annotation></semantics></math>.
Let <math id="p9.m27" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> be the size of the <math id="p9.m28" class="ltx_Math" alttext="1" display="inline"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-minimal testcase found
by Lithium and <math id="p9.m29" class="ltx_Math" alttext="m=\lceil\log_{2}(M)\rceil" display="inline"><semantics><mrow><mi>m</mi><mo>=</mo><mrow><mo stretchy="false">⌈</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">m=\lceil\log_{2}(M)\rceil</annotation></semantics></math>.</p>
</div>
<div id="p10" class="ltx_para">
<p class="ltx_p">Lithium will always perform the <math id="p10.m1" class="ltx_Math" alttext="n-1" display="inline"><semantics><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> initial steps above and check at least
one subset at each step. At the end, it needs to do <math id="p10.m2" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> operations to
be sure that the testcase is <math id="p10.m3" class="ltx_Math" alttext="1" display="inline"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-minimal.
So <math id="p10.m4" class="ltx_Math" alttext="C_{N}\geq\lceil\log_{2}(N)\rceil+M-1=\Omega(\log_{2}(N)+M)" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>≥</mo><mrow><mrow><mrow><mo stretchy="false">⌈</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">⌉</mo></mrow><mo>+</mo><mi>M</mi></mrow><mo>-</mo><mn>1</mn></mrow><mo>=</mo><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}\geq\lceil\log_{2}(N)\rceil+M-1=\Omega(\log_{2}(N)+M)</annotation></semantics></math>.
Now, consider the case where <math id="p10.m5" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> monotonic and has one minimal reduction
<math id="p10.m6" class="ltx_Math" alttext="T=[1,M]" display="inline"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>M</mi><mo stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex">T=[1,M]</annotation></semantics></math>. Then <math id="p10.m7" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is included in the chunk <math id="p10.m8" class="ltx_Math" alttext="[1,2^{m}]" display="inline"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><msup><mn>2</mn><mi>m</mi></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2^{m}]</annotation></semantics></math> from step
<math id="p10.m9" class="ltx_Math" alttext="k=n-m" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow></mrow><annotation encoding="application/x-tex">k=n-m</annotation></semantics></math>. Because <math id="p10.m10" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic, this means that at step <math id="p10.m11" class="ltx_Math" alttext="k=1" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math>,
we do two verifications and the second chunk is removed because it does
not contain the <math id="p10.m12" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> (and the third one too
if <math id="p10.m13" class="ltx_Math" alttext="N" display="inline"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> is not a power of two), at step <math id="p10.m14" class="ltx_Math" alttext="k=2" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math> it
remains two chunks, we do two verifications and the second chunk is removed etc
until <math id="p10.m15" class="ltx_Math" alttext="k=n-m" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow></mrow><annotation encoding="application/x-tex">k=n-m</annotation></semantics></math>. For <math id="p10.m16" class="ltx_Math" alttext="k&gt;n-m" display="inline"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow></mrow><annotation encoding="application/x-tex">k&gt;n-m</annotation></semantics></math>,
the number of chunk can grow again: 2, 4, 8… that is we handle at most
<math id="p10.m17" class="ltx_Math" alttext="2^{1+k-(n-m)}" display="inline"><semantics><msup><mn>2</mn><mrow><mrow><mn>1</mn><mo>+</mo><mi>k</mi></mrow><mo>-</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msup><annotation encoding="application/x-tex">2^{1+k-(n-m)}</annotation></semantics></math> chunks from step <math id="p10.m18" class="ltx_Math" alttext="n-m+1" display="inline"><semantics><mrow><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-m+1</annotation></semantics></math> to <math id="p10.m19" class="ltx_Math" alttext="n-1" display="inline"><semantics><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>.
At step <math id="p10.m20" class="ltx_Math" alttext="k=n" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k=n</annotation></semantics></math>, a first round
of at most <math id="p10.m21" class="ltx_Math" alttext="2^{m}" display="inline"><semantics><msup><mn>2</mn><mi>m</mi></msup><annotation encoding="application/x-tex">2^{m}</annotation></semantics></math> verifications ensure that the testcase is of size <math id="p10.m22" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> and a
second round of <math id="p10.m23" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> verifications ensure that it is <math id="p10.m24" class="ltx_Math" alttext="1" display="inline"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-minimal. So
<math id="p10.m25" class="ltx_Math" alttext="C_{N}\leq 1+\left(\sum_{k=1}^{n-m}2\right)+\left(\sum_{k=n-m+1}^{n}2^{1+k-(n-m%
)}\right)+2^{m}+M=1+2(n-m)+2^{m}-1+2^{m}+M" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>≤</mo><mrow><mn>1</mn><mo>+</mo><mrow><mo>(</mo><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow></msubsup><mn>2</mn></mrow><mo>)</mo></mrow><mo>+</mo><mrow><mo>(</mo><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mrow><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><mo>+</mo><mn>1</mn></mrow></mrow><mi>n</mi></msubsup><msup><mn>2</mn><mrow><mrow><mn>1</mn><mo>+</mo><mi>k</mi></mrow><mo>-</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msup></mrow><mo>)</mo></mrow><mo>+</mo><msup><mn>2</mn><mi>m</mi></msup><mo>+</mo><mi>M</mi></mrow><mo>=</mo><mrow><mrow><mrow><mn>1</mn><mo>+</mo><mrow><mn>2</mn><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><msup><mn>2</mn><mi>m</mi></msup></mrow><mo>-</mo><mn>1</mn></mrow><mo>+</mo><msup><mn>2</mn><mi>m</mi></msup><mo>+</mo><mi>M</mi></mrow></mrow><annotation encoding="application/x-tex">C_{N}\leq 1+\left(\sum_{k=1}^{n-m}2\right)+\left(\sum_{k=n-m+1}^{n}2^{1+k-(n-m%
)}\right)+2^{m}+M=1+2(n-m)+2^{m}-1+2^{m}+M</annotation></semantics></math> and after simplification <math id="p10.m26" class="ltx_Math" alttext="C_{N}=O(\log_{2}(N)+M)" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}=O(\log_{2}(N)+M)</annotation></semantics></math>.
Hence the lower bound <math id="p10.m27" class="ltx_Math" alttext="\Omega(\log_{2}(N)+M)" display="inline"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(\log_{2}(N)+M)</annotation></semantics></math> is optimal. The previous example
suggests the
following generalization: a testcase <math id="p10.m28" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is <math id="p10.m29" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math><span class="ltx_text ltx_font_italic">-clustered</span> if it can be
written as the union of <math id="p10.m30" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> nonempty closed
intervals <math id="p10.m31" class="ltx_Math" alttext="T=I_{1}\cup I_{2}\cup...\cup I_{C}" display="inline"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><msub><mi>I</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>I</mi><mn>2</mn></msub><mo>∪</mo><mi mathvariant="normal">…</mi><mo>∪</mo><msub><mi>I</mi><mi>C</mi></msub></mrow></mrow><annotation encoding="application/x-tex">T=I_{1}\cup I_{2}\cup...\cup I_{C}</annotation></semantics></math>. If the
minimal testcase found by Lithium is <math id="p10.m32" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>-clustered, each <math id="p10.m33" class="ltx_Math" alttext="I_{j}" display="inline"><semantics><msub><mi>I</mi><mi>j</mi></msub><annotation encoding="application/x-tex">I_{j}</annotation></semantics></math> is of length at
most <math id="p10.m34" class="ltx_Math" alttext="M\leq 2^{m}" display="inline"><semantics><mrow><mi>M</mi><mo>≤</mo><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">M\leq 2^{m}</annotation></semantics></math> and so <math id="p10.m35" class="ltx_Math" alttext="I_{j}" display="inline"><semantics><msub><mi>I</mi><mi>j</mi></msub><annotation encoding="application/x-tex">I_{j}</annotation></semantics></math> intersects at most 2 chunks of length <math id="p10.m36" class="ltx_Math" alttext="2^{m}" display="inline"><semantics><msup><mn>2</mn><mi>m</mi></msup><annotation encoding="application/x-tex">2^{m}</annotation></semantics></math>
from the step <math id="p10.m37" class="ltx_Math" alttext="k=n-m" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow></mrow><annotation encoding="application/x-tex">k=n-m</annotation></semantics></math>. So <math id="p10.m38" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> intersects at most <math id="p10.m39" class="ltx_Math" alttext="2C" display="inline"><semantics><mrow><mn>2</mn><mo>⁢</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">2C</annotation></semantics></math> chunks from
the step <math id="p10.m40" class="ltx_Math" alttext="k=n-m" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow></mrow><annotation encoding="application/x-tex">k=n-m</annotation></semantics></math> and a fortiori from all the steps <math id="p10.m41" class="ltx_Math" alttext="k\leq n-m" display="inline"><semantics><mrow><mi>k</mi><mo>≤</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow></mrow><annotation encoding="application/x-tex">k\leq n-m</annotation></semantics></math>.
Suppose that <math id="p10.m42" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic. Then if <math id="p10.m43" class="ltx_Math" alttext="c" display="inline"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> is a chunk that does not contain any
element of <math id="p10.m44" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> then <math id="p10.m45" class="ltx_Math" alttext="T\setminus c" display="inline"><semantics><mrow><mi>T</mi><mo>∖</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">T\setminus c</annotation></semantics></math> is a reduction of <math id="p10.m46" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> and so
Lithium will remove the chunk <math id="p10.m47" class="ltx_Math" alttext="c" display="inline"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>. Hence at each step <math id="p10.m48" class="ltx_Math" alttext="k\leq n-m" display="inline"><semantics><mrow><mi>k</mi><mo>≤</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow></mrow><annotation encoding="application/x-tex">k\leq n-m</annotation></semantics></math>,
at most <math id="p10.m49" class="ltx_Math" alttext="2C" display="inline"><semantics><mrow><mn>2</mn><mo>⁢</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">2C</annotation></semantics></math> chunks survive and so there are at most <math id="p10.m50" class="ltx_Math" alttext="4C" display="inline"><semantics><mrow><mn>4</mn><mo>⁢</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">4C</annotation></semantics></math> chunks at the next
step. A computation similar to what we have done for <math id="p10.m51" class="ltx_Math" alttext="T=[1,M]" display="inline"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>M</mi><mo stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex">T=[1,M]</annotation></semantics></math> shows that
<math id="p10.m52" class="ltx_Math" alttext="C_{N}=O(C(\log_{2}(N)+M))" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>C</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}=O(C(\log_{2}(N)+M))</annotation></semantics></math> if the final
testcase found by Lithium is <math id="p10.m53" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>-clustered. Note that we always have
<math id="p10.m54" class="ltx_Math" alttext="M=o(N)" display="inline"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">M=o(N)</annotation></semantics></math> and <math id="p10.m55" class="ltx_Math" alttext="\log_{2}(N)=o(N)" display="inline"><semantics><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">\log_{2}(N)=o(N)</annotation></semantics></math>. So if <math id="p10.m56" class="ltx_Math" alttext="C=O(1)" display="inline"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C=O(1)</annotation></semantics></math> then <math id="p10.m57" class="ltx_Math" alttext="C_{N}=O(\log_{2}(N)+M)=o(N)" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}=O(\log_{2}(N)+M)=o(N)</annotation></semantics></math> is small
as wanted. Also, the final testcase is always <math id="p10.m58" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>-clustered (union of intervals
that are singletons!)
so we found that the monotonic case is <math id="p10.m59" class="ltx_Math" alttext="O(M(\log_{2}(N)+M))" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(M(\log_{2}(N)+M))</annotation></semantics></math>.
We shall give a better bound below.</p>
</div>
<div id="p11" class="ltx_para">
<p class="ltx_p">Now, for each step
<math id="p11.m1" class="ltx_Math" alttext="k=1,2,...,n-1" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow><annotation encoding="application/x-tex">k=1,2,...,n-1</annotation></semantics></math>, Lithium splits the testcase in at most
<math id="p11.m2" class="ltx_Math" alttext="2^{k}" display="inline"><semantics><msup><mn>2</mn><mi>k</mi></msup><annotation encoding="application/x-tex">2^{k}</annotation></semantics></math> chunk and try to remove each chunk. Then it does at most <math id="p11.m3" class="ltx_Math" alttext="N" display="inline"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> steps
before stopping or removing one chunk (so the testcase becomes of size at most
<math id="p11.m4" class="ltx_Math" alttext="N-1" display="inline"><semantics><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math>), then it does at most <math id="p11.m5" class="ltx_Math" alttext="N-1" display="inline"><semantics><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math> steps before stopping or removing one more
chunk (so the testcase becomes of size at most <math id="p11.m6" class="ltx_Math" alttext="N-1" display="inline"><semantics><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math>), …,
then it does at most <math id="p11.m7" class="ltx_Math" alttext="M+1" display="inline"><semantics><mrow><mi>M</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M+1</annotation></semantics></math> steps before stopping or removing one more
chunk (so the testcase becomes of size at most <math id="p11.m8" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>). Then the testcase is
exactly of size <math id="p11.m9" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> and Lithium does at most <math id="p11.m10" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> additional verifications.
This gives
<math id="p11.m11" class="ltx_Math" alttext="C_{N}\leq\sum_{k=1}^{n-1}2^{k}+\sum_{k=M}^{N}k=2^{n}-2+\frac{N(N+1)-M(M-1)}{2}%
=O(N^{2})" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>≤</mo><mrow><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup><msup><mn>2</mn><mi>k</mi></msup></mrow><mo>+</mo><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mi>M</mi></mrow><mi>N</mi></msubsup><mi>k</mi></mrow></mrow><mo>=</mo><mrow><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><mn>2</mn></mrow><mo>+</mo><mfrac><mrow><mrow><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>-</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mn>2</mn></mfrac></mrow><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}\leq\sum_{k=1}^{n-1}2^{k}+\sum_{k=M}^{N}k=2^{n}-2+\frac{N(N+1)-M(M-1)}{2}%
=O(N^{2})</annotation></semantics></math> verifications.
This bound is optimal if <math id="p11.m12" class="ltx_Math" alttext="1\leq M\leq 2^{n-1}" display="inline"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1\leq M\leq 2^{n-1}</annotation></semantics></math> (this is asymptotically
true since we assume <math id="p11.m13" class="ltx_Math" alttext="M=o(N)" display="inline"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">M=o(N)</annotation></semantics></math>): consider the cases where
the proper reductions of <math id="p11.m14" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> are exactly the segments
<math id="p11.m15" class="ltx_Math" alttext="[1,k]\ (2^{n-1}+1\leq k\leq 2^{n}-1)" display="inline"><semantics><mrow><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo rspace="7.5pt" stretchy="false">]</mo></mrow><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">[1,k]\ (2^{n-1}+1\leq k\leq 2^{n}-1)</annotation></semantics></math> and
<math id="p11.m16" class="ltx_Math" alttext="[k,2^{n-1}+1]\ (2\leq k\leq 2^{n-1}-M+2)" display="inline"><semantics><mrow><mrow><mo stretchy="false">[</mo><mi>k</mi><mo>,</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>1</mn><mo rspace="7.5pt" stretchy="false">]</mo></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>-</mo><mi>M</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">[k,2^{n-1}+1]\ (2\leq k\leq 2^{n-1}-M+2)</annotation></semantics></math>.
The testcase will be preserved
during the first phase. Then we will keep browsing at least the first half to
remove elements at position <math id="p11.m17" class="ltx_Math" alttext="2^{n-1}+2\leq k\leq 2^{n}-1" display="inline"><semantics><mrow><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>2</mn></mrow><mo>≤</mo><mi>k</mi><mo>≤</mo><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">2^{n-1}+2\leq k\leq 2^{n}-1</annotation></semantics></math>. So
<math id="p11.m18" class="ltx_Math" alttext="C_{N}\geq\sum_{k=2^{n-1}+2}^{2^{n}-1}2^{n-1}=2^{n-1}\left(2^{n-1}-2\right)=%
\Omega(N^{2})" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>≥</mo><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>2</mn></mrow></mrow><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><mn>1</mn></mrow></msubsup><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow><mo>=</mo><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mrow><mo>(</mo><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>-</mo><mn>2</mn></mrow><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}\geq\sum_{k=2^{n-1}+2}^{2^{n}-1}2^{n-1}=2^{n-1}\left(2^{n-1}-2\right)=%
\Omega(N^{2})</annotation></semantics></math>.</p>
</div>
<div id="p12" class="ltx_para">
<p class="ltx_p">We now come back to the case where <math id="p12.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is
monotonic. We will prove that the worst case is
<math id="p12.m2" class="ltx_Math" alttext="C_{N}=\Theta\left(M\log_{2}(\frac{N}{M})\right)" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>=</mo><mrow><mi mathvariant="normal">Θ</mi><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}=\Theta\left(M\log_{2}(\frac{N}{M})\right)</annotation></semantics></math> and so our assumption
<math id="p12.m3" class="ltx_Math" alttext="M=o(N)" display="inline"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">M=o(N)</annotation></semantics></math> gives
<math id="p12.m4" class="ltx_Math" alttext="M\log_{2}(\frac{N}{M})=\left(-\frac{M}{N}\log_{2}(\frac{M}{N})\right)N=o(N)" display="inline"><semantics><mrow><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mo>(</mo><mrow><mo>-</mo><mrow><mfrac><mi>M</mi><mi>N</mi></mfrac><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mfrac><mi>M</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>)</mo></mrow><mo>⁢</mo><mi>N</mi></mrow><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">M\log_{2}(\frac{N}{M})=\left(-\frac{M}{N}\log_{2}(\frac{M}{N})\right)N=o(N)</annotation></semantics></math> as we expected. During the steps
<math id="p12.m5" class="ltx_Math" alttext="1\leq k\leq m" display="inline"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\leq k\leq m</annotation></semantics></math>, we test at most <math id="p12.m6" class="ltx_Math" alttext="2^{k}" display="inline"><semantics><msup><mn>2</mn><mi>k</mi></msup><annotation encoding="application/x-tex">2^{k}</annotation></semantics></math> chunks. When <math id="p12.m7" class="ltx_Math" alttext="k=m" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">k=m</annotation></semantics></math>,
<math id="p12.m8" class="ltx_Math" alttext="2^{m}\geq M" display="inline"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>≥</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">2^{m}\geq M</annotation></semantics></math> chunks but at most <math id="p12.m9" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> distinct chunks contain
an element from the final reduction.
By monocity, at most <math id="p12.m10" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> chunks will survive and there are at most
<math id="p12.m11" class="ltx_Math" alttext="2M" display="inline"><semantics><mrow><mn>2</mn><mo>⁢</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">2M</annotation></semantics></math> chunks at step <math id="p12.m12" class="ltx_Math" alttext="m+1" display="inline"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math>. Again, only <math id="p12.m13" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> chunks will survive at step
<math id="p12.m14" class="ltx_Math" alttext="m+2" display="inline"><semantics><mrow><mi>m</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m+2</annotation></semantics></math> and so on until <math id="p12.m15" class="ltx_Math" alttext="k=n-1" display="inline"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">k=n-1</annotation></semantics></math>. A the final step, it remains at most <math id="p12.m16" class="ltx_Math" alttext="2M" display="inline"><semantics><mrow><mn>2</mn><mo>⁢</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">2M</annotation></semantics></math>
elements. Again by monocity a first round of <math id="p12.m17" class="ltx_Math" alttext="2M" display="inline"><semantics><mrow><mn>2</mn><mo>⁢</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">2M</annotation></semantics></math> tests will make <math id="p12.m18" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> elements
survive and we finally need <math id="p12.m19" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> additional tests to ensure that the test case
is minimal. Hence
<math id="p12.m20" class="ltx_Math" alttext="C_{N}\leq{\sum_{k=1}^{m}2^{k}}+{\sum_{k=m+1}^{n}2M}+M=2^{m+1}-3+M(2(n-m)+1)=O(%
M\log_{2}(\frac{N}{M}))" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>≤</mo><mrow><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msup><mn>2</mn><mi>k</mi></msup></mrow><mo>+</mo><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></mrow><mi>n</mi></msubsup><mrow><mn>2</mn><mo>⁢</mo><mi>M</mi></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo>=</mo><mrow><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>-</mo><mn>3</mn></mrow><mo>+</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mn>2</mn><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}\leq{\sum_{k=1}^{m}2^{k}}+{\sum_{k=m+1}^{n}2M}+M=2^{m+1}-3+M(2(n-m)+1)=O(%
M\log_{2}(\frac{N}{M}))</annotation></semantics></math>. This bound is
optimal: if <math id="p12.m21" class="ltx_Math" alttext="M=2^{m}" display="inline"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">M=2^{m}</annotation></semantics></math>, consider the case where
<math id="p12.m22" class="ltx_Math" alttext="T=\{j2^{n-m}+1:0\leq j&lt;2^{m}\}" display="inline"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>j</mi><mo>⁢</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow></msup></mrow><mo>+</mo><mn>1</mn></mrow><mo>:</mo><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><msup><mn>2</mn><mi>m</mi></msup></mrow><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">T=\{j2^{n-m}+1:0\leq j&lt;2^{m}\}</annotation></semantics></math> is the only minimal testcase
(and <math id="p12.m23" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> monotonic) ; if <math id="p12.m24" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> is not a power of two, consider the same <math id="p12.m25" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
with <math id="p12.m26" class="ltx_Math" alttext="2^{m}-M" display="inline"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>-</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">2^{m}-M</annotation></semantics></math> points removed at odd positions. Then for each step
<math id="p12.m27" class="ltx_Math" alttext="1\leq k\leq m-1" display="inline"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">1\leq k\leq m-1</annotation></semantics></math>, no chunks inside <math id="p12.m28" class="ltx_Math" alttext="[1,2^{n}]" display="inline"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2^{n}]</annotation></semantics></math> are removed. Then some
chunks in <math id="p12.m29" class="ltx_Math" alttext="[1,2^{n}]" display="inline"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2^{n}]</annotation></semantics></math> are removed (none if <math id="p12.m30" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> is a power of two) at
step <math id="p12.m31" class="ltx_Math" alttext="m" display="inline"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> and it remains <math id="p12.m32" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> chunks. Then for steps <math id="p12.m33" class="ltx_Math" alttext="m+1\leq k\leq n-1" display="inline"><semantics><mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mo>≤</mo><mi>k</mi><mo>≤</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">m+1\leq k\leq n-1</annotation></semantics></math>
there are always exactly <math id="p12.m34" class="ltx_Math" alttext="2M" display="inline"><semantics><mrow><mn>2</mn><mo>⁢</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">2M</annotation></semantics></math> chunks to handle. So
<math id="p12.m35" class="ltx_Math" alttext="C_{N}\geq\sum_{m+1\leq k\leq n-1}2M=2M(n-m-2)=2M(\log_{2}(\frac{N}{M})-2)=%
\Omega(M\log_{2}(\frac{N}{M}))" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>≥</mo><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mo>≤</mo><mi>k</mi><mo>≤</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></mrow></msub><mrow><mn>2</mn><mo>⁢</mo><mi>M</mi></mrow></mrow><mo>=</mo><mrow><mn>2</mn><mo>⁢</mo><mi>M</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi><mo>-</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mn>2</mn><mo>⁢</mo><mi>M</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo stretchy="false">)</mo></mrow></mrow><mo>-</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}\geq\sum_{m+1\leq k\leq n-1}2M=2M(n-m-2)=2M(\log_{2}(\frac{N}{M})-2)=%
\Omega(M\log_{2}(\frac{N}{M}))</annotation></semantics></math>.</p>
</div>
<div id="p13" class="ltx_para">
<p class="ltx_p">We note that we have used two different methods to bound the number of
verifications in the general monotonic case, or when the testcase is
<math id="p13.m1" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>-clustered. One naturally wonders what happens when we combine the two
techniques. So let <math id="p13.m2" class="ltx_Math" alttext="c=\lceil\log_{2}C\rceil\leq m" display="inline"><semantics><mrow><mi>c</mi><mo>=</mo><mrow><mo stretchy="false">⌈</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>C</mi></mrow><mo stretchy="false">⌉</mo></mrow><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">c=\lceil\log_{2}C\rceil\leq m</annotation></semantics></math>. From step <math id="p13.m3" class="ltx_Math" alttext="1" display="inline"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math> to <math id="p13.m4" class="ltx_Math" alttext="c" display="inline"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>,
the best bound we found was <math id="p13.m5" class="ltx_Math" alttext="O(2^{k})" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(2^{k})</annotation></semantics></math> ; from step <math id="p13.m6" class="ltx_Math" alttext="c" display="inline"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> to <math id="p13.m7" class="ltx_Math" alttext="m" display="inline"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>, it was
<math id="p13.m8" class="ltx_Math" alttext="O(C)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(C)</annotation></semantics></math> ; from step <math id="p13.m9" class="ltx_Math" alttext="m" display="inline"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> to <math id="p13.m10" class="ltx_Math" alttext="n-m" display="inline"><semantics><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math> it was <math id="p13.m11" class="ltx_Math" alttext="O(C)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(C)</annotation></semantics></math> again ; from step
<math id="p13.m12" class="ltx_Math" alttext="n-m" display="inline"><semantics><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math> to <math id="p13.m13" class="ltx_Math" alttext="n-c" display="inline"><semantics><mrow><mi>n</mi><mo>-</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">n-c</annotation></semantics></math>, it was <math id="p13.m14" class="ltx_Math" alttext="O(2^{1-k-(n-m)}C)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mn>2</mn><mrow><mn>1</mn><mo>-</mo><mi>k</mi><mo>-</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msup><mo>⁢</mo><mi>C</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(2^{1-k-(n-m)}C)</annotation></semantics></math> and finally from step <math id="p13.m15" class="ltx_Math" alttext="n-c" display="inline"><semantics><mrow><mi>n</mi><mo>-</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">n-c</annotation></semantics></math>
to <math id="p13.m16" class="ltx_Math" alttext="n" display="inline"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, including final verifications, it was <math id="p13.m17" class="ltx_Math" alttext="O(M)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(M)</annotation></semantics></math>. Taking the sum, we
get <math id="p13.m18" class="ltx_Math" alttext="C_{N}=O(2^{c}+((n-m)-c)C+2^{(n-c-(n-m))}C+(n-(n-c))M)=O(C\left(1+\log_{2}{%
\left(\frac{N}{MC}\right)}\right)+M(1+\log_{2}{C}))" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mn>2</mn><mi>c</mi></msup><mo>+</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow><mo>-</mo><mi>c</mi></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>C</mi></mrow><mo>+</mo><mrow><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>c</mi><mo>-</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></msup><mo>⁢</mo><mi>C</mi></mrow><mo>+</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>-</mo><mi>c</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>M</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>C</mi><mo>⁢</mo><mrow><mo>(</mo><mrow><mn>1</mn><mo>+</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo>(</mo><mfrac><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>C</mi></mrow></mfrac><mo>)</mo></mrow></mrow></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>+</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>C</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}=O(2^{c}+((n-m)-c)C+2^{(n-c-(n-m))}C+(n-(n-c))M)=O(C\left(1+\log_{2}{%
\left(\frac{N}{MC}\right)}\right)+M(1+\log_{2}{C}))</annotation></semantics></math>
Because <math id="p13.m19" class="ltx_Math" alttext="C=O(M)" display="inline"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C=O(M)</annotation></semantics></math>, this becomes
<math id="p13.m20" class="ltx_Math" alttext="C_{N}=O(C\log_{2}{\left(\frac{N}{MC}\right)}+M(1+\log_{2}{C}))" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>C</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo>(</mo><mfrac><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>C</mi></mrow></mfrac><mo>)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>+</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>C</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}=O(C\log_{2}{\left(\frac{N}{MC}\right)}+M(1+\log_{2}{C}))</annotation></semantics></math>. If
<math id="p13.m21" class="ltx_Math" alttext="C=O(1)" display="inline"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C=O(1)</annotation></semantics></math>, then we get <math id="p13.m22" class="ltx_Math" alttext="C_{N}=O(\log_{2}(N)+M)" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}=O(\log_{2}(N)+M)</annotation></semantics></math>. At the opposite,
if <math id="p13.m23" class="ltx_Math" alttext="C=\Omega(M)" display="inline"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C=\Omega(M)</annotation></semantics></math>, we get <math id="p13.m24" class="ltx_Math" alttext="C_{N}=\Omega(M\log_{2}{\left(\frac{N}{M}\right)})" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>=</mo><mrow><mi mathvariant="normal">Ω</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo>(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo>)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}=\Omega(M\log_{2}{\left(\frac{N}{M}\right)})</annotation></semantics></math>.
If <math id="p13.m25" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> is not <math id="p13.m26" class="ltx_Math" alttext="O(1)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math> but <math id="p13.m27" class="ltx_Math" alttext="C=o(M)" display="inline"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C=o(M)</annotation></semantics></math> then <math id="p13.m28" class="ltx_Math" alttext="1=o(\log_{2}{C})" display="inline"><semantics><mrow><mn>1</mn><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>C</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">1=o(\log_{2}{C})</annotation></semantics></math> and
<math id="p13.m29" class="ltx_Math" alttext="C\log_{2}(C)=o(M\log_{2}{C})" display="inline"><semantics><mrow><mrow><mi>C</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>C</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C\log_{2}(C)=o(M\log_{2}{C})</annotation></semantics></math> and so the expression can be simplified to
<math id="p13.m30" class="ltx_Math" alttext="C_{N}=O(C\log_{2}{\left(\frac{N}{M}\right)}+M\log_{2}{C})" display="inline"><semantics><mrow><msub><mi>C</mi><mi>N</mi></msub><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>C</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo>(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo>)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>C</mi></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C_{N}=O(C\log_{2}{\left(\frac{N}{M}\right)}+M\log_{2}{C})</annotation></semantics></math>. Hence we have
obtained an intermediate result between the worst and best monotonic cases and
shown how the role played by the number of clusters: the less the final testcase
is clustered, the faster Lithium finds it. The results are summarized in the
following table:</p>
</div>
<figure id="Ch0.F1" class="ltx_figure">
<table class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_r ltx_border_t"></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t">Number of tests</th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">Best case</th>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><math id="Ch0.F1.m1" class="ltx_Math" alttext="\Theta(\log_{2}(N)+M)" display="inline"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log_{2}(N)+M)</annotation></semantics></math></td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">
<math id="Ch0.F1.m2" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic ; <math id="Ch0.F1.m3" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is <math id="Ch0.F1.m4" class="ltx_Math" alttext="O(1)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math>-clustered</th>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><math id="Ch0.F1.m5" class="ltx_Math" alttext="O(\log_{2}(N)+M)" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log_{2}(N)+M)</annotation></semantics></math></td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">
<math id="Ch0.F1.m6" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic ; <math id="Ch0.F1.m7" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is <math id="Ch0.F1.m8" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>-clustered (<math id="Ch0.F1.m9" class="ltx_Math" alttext="C=o(M)" display="inline"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">C=o(M)</annotation></semantics></math> and unbounded)</th>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><math id="Ch0.F1.m10" class="ltx_Math" alttext="O(C\log_{2}{\left(\frac{N}{M}\right)}+M\log_{2}{C})" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>C</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo>(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo>)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>C</mi></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(C\log_{2}{\left(\frac{N}{M}\right)}+M\log_{2}{C})</annotation></semantics></math></td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_r ltx_border_t">
<math id="Ch0.F1.m11" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic</th>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><math id="Ch0.F1.m12" class="ltx_Math" alttext="O\left(M\log_{2}\left(\frac{N}{M}\right)\right);o(N)" display="inline"><semantics><mrow><mrow><mi>O</mi><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo>(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo>)</mo></mrow></mrow></mrow><mo>)</mo></mrow></mrow><mo>;</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">O\left(M\log_{2}\left(\frac{N}{M}\right)\right);o(N)</annotation></semantics></math></td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_b ltx_border_l ltx_border_r ltx_border_t">Worst case</th>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t"><math id="Ch0.F1.m13" class="ltx_Math" alttext="\Theta(N^{2})" display="inline"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(N^{2})</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 0.1: </span>Performance of Lithium’s algorithm for some initial testcase <math id="Ch0.F1.m21" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> of
size <math id="Ch0.F1.m22" class="ltx_Math" alttext="N" display="inline"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> and final reduction <math id="Ch0.F1.m23" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> of size <math id="Ch0.F1.m24" class="ltx_Math" alttext="M=o(N)" display="inline"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">M=o(N)</annotation></semantics></math>. <math id="Ch0.F1.m25" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is <math id="Ch0.F1.m26" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>-clustered if it
is the union of <math id="Ch0.F1.m27" class="ltx_Math" alttext="C" display="inline"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> intervals.</figcaption>
</figure>
<div id="p14" class="ltx_para">
<p class="ltx_p">In the ddmin algorithm, at each step we add a preliminary round where we try
to immediately reduce to a single chunk (or equivalently to remove the
complement of a chunk). Actually, the ddmin algorithm only does this preliminary
round at steps where there are more than 2 chunks for otherwise it would do
twice the same work. For each step <math id="p14.m1" class="ltx_Math" alttext="k&gt;1" display="inline"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k&gt;1</annotation></semantics></math>, if one chunk
<math id="p14.m2" class="ltx_Math" alttext="c_{1}" display="inline"><semantics><msub><mi>c</mi><mn>1</mn></msub><annotation encoding="application/x-tex">c_{1}</annotation></semantics></math> is a reduction of <math id="p14.m3" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> then <math id="p14.m4" class="ltx_Math" alttext="c_{1}\subseteq c_{2}" display="inline"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>⊆</mo><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_{1}\subseteq c_{2}</annotation></semantics></math> for some chunk <math id="p14.m5" class="ltx_Math" alttext="c_{2}" display="inline"><semantics><msub><mi>c</mi><mn>2</mn></msub><annotation encoding="application/x-tex">c_{2}</annotation></semantics></math> at the
previous step <math id="p14.m6" class="ltx_Math" alttext="k-1" display="inline"><semantics><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math>. Now if <math id="p14.m7" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic then, at level <math id="p14.m8" class="ltx_Math" alttext="k-1" display="inline"><semantics><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math>, removing all
but the chunk <math id="p14.m9" class="ltx_Math" alttext="c_{2}" display="inline"><semantics><msub><mi>c</mi><mn>2</mn></msub><annotation encoding="application/x-tex">c_{2}</annotation></semantics></math> gives a subset that contains <math id="p14.m10" class="ltx_Math" alttext="c_{1}" display="inline"><semantics><msub><mi>c</mi><mn>1</mn></msub><annotation encoding="application/x-tex">c_{1}</annotation></semantics></math> and so a reduction of <math id="p14.m11" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
by monocity. Hence on chunk survive at level <math id="p14.m12" class="ltx_Math" alttext="k" display="inline"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> and
there are exactly 2 chunks at level <math id="p14.m13" class="ltx_Math" alttext="k" display="inline"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> and so the ddmin
algorithm is exactly Lithium’s algorithm when <math id="p14.m14" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic. The ddmin
algorithm keeps in memory the subsets that we didn’t find
interesting in order to avoid
repeating them. However, if we only reduce to the complement of a chunk, then
we can never repeat the same subset and so this additional work is useless.
That’s the case if <math id="p14.m15" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic.</p>
</div>
<div id="p15" class="ltx_para">
<p class="ltx_p">Finally,
if <math id="p15.m1" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic Jesse proposes a simpler approach based on a binary search.
Suppose first that there is only one minimal testcase <math id="p15.m2" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>.
If <math id="p15.m3" class="ltx_Math" alttext="k\geq\min T" display="inline"><semantics><mrow><mi>k</mi><mo>≥</mo><mrow><mi>min</mi><mo>⁡</mo><mi>T</mi></mrow></mrow><annotation encoding="application/x-tex">k\geq\min T</annotation></semantics></math> then <math id="p15.m4" class="ltx_Math" alttext="[1,k]" display="inline"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,k]</annotation></semantics></math> intersects <math id="p15.m5" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> and so
<math id="p15.m6" class="ltx_Math" alttext="U_{k}=S\setminus[1,k]\neq T" display="inline"><semantics><mrow><msub><mi>U</mi><mi>k</mi></msub><mo>=</mo><mrow><mi>S</mi><mo>∖</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></mrow><mo>≠</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">U_{k}=S\setminus[1,k]\neq T</annotation></semantics></math>. Then <math id="p15.m7" class="ltx_Math" alttext="U_{k}" display="inline"><semantics><msub><mi>U</mi><mi>k</mi></msub><annotation encoding="application/x-tex">U_{k}</annotation></semantics></math> is not a reduction of <math id="p15.m8" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> for
otherwise a minimal reduction of <math id="p15.m9" class="ltx_Math" alttext="U_{k}" display="inline"><semantics><msub><mi>U</mi><mi>k</mi></msub><annotation encoding="application/x-tex">U_{k}</annotation></semantics></math> would be a minimal reduction of <math id="p15.m10" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
distinct from <math id="p15.m11" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> which we exclude by hypothesis. If instead <math id="p15.m12" class="ltx_Math" alttext="k&lt;\min T" display="inline"><semantics><mrow><mi>k</mi><mo>&lt;</mo><mrow><mi>min</mi><mo>⁡</mo><mi>T</mi></mrow></mrow><annotation encoding="application/x-tex">k&lt;\min T</annotation></semantics></math> then
<math id="p15.m13" class="ltx_Math" alttext="[1,k]" display="inline"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,k]</annotation></semantics></math> does not intersect <math id="p15.m14" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> and
<math id="p15.m15" class="ltx_Math" alttext="U_{k}=S\setminus[1,k]\supseteq T\setminus[1,k]\supseteq T" display="inline"><semantics><mrow><msub><mi>U</mi><mi>k</mi></msub><mo>=</mo><mrow><mi>S</mi><mo>∖</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></mrow><mo>⊇</mo><mrow><mi>T</mi><mo>∖</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></mrow><mo>⊇</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">U_{k}=S\setminus[1,k]\supseteq T\setminus[1,k]\supseteq T</annotation></semantics></math> is a
reduction of <math id="p15.m16" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> because <math id="p15.m17" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic. So we can use a binary search
to find <math id="p15.m18" class="ltx_Math" alttext="\min T" display="inline"><semantics><mrow><mi>min</mi><mo>⁡</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\min T</annotation></semantics></math> by testing at most <math id="p15.m19" class="ltx_Math" alttext="\log_{2}(N)" display="inline"><semantics><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log_{2}(N)</annotation></semantics></math> testcases
(modulo some constant). Then we try with intervals
<math id="p15.m20" class="ltx_Math" alttext="[1+\min T,k]" display="inline"><semantics><mrow><mo stretchy="false">[</mo><mrow><mn>1</mn><mo>+</mo><mrow><mi>min</mi><mo>⁡</mo><mi>T</mi></mrow></mrow><mo>,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1+\min T,k]</annotation></semantics></math> to find the second least element of <math id="p15.m21" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> in at most
<math id="p15.m22" class="ltx_Math" alttext="\log_{2}(N)" display="inline"><semantics><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log_{2}(N)</annotation></semantics></math>. We continue until we find the <math id="p15.m23" class="ltx_Math" alttext="M" display="inline"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>-th element of <math id="p15.m24" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>. Clearly,
this gives <math id="p15.m25" class="ltx_Math" alttext="M\log_{2}(N)" display="inline"><semantics><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">M\log_{2}(N)</annotation></semantics></math> verifications which sounds equivalent to
Jesse’s bound with even a better constant factor. Note that the algorithm
still works if we remove the assumption that there is only one minimal testcase
<math id="p15.m26" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>. We start by <math id="p15.m27" class="ltx_Math" alttext="S=S_{1}" display="inline"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S=S_{1}</annotation></semantics></math> and find
<math id="p15.m28" class="ltx_Math" alttext="x_{1}=\max\{\min T:T\text{ is a minimal reduction of }S_{1}\}" display="inline"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>min</mi><mo>⁡</mo><mi>T</mi></mrow><mo>:</mo><mrow><mi>T</mi><mo>⁢</mo><mtext> is a minimal reduction of </mtext><mo>⁢</mo><msub><mi>S</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">x_{1}=\max\{\min T:T\text{ is a minimal reduction of }S_{1}\}</annotation></semantics></math>: if
<math id="p15.m29" class="ltx_Math" alttext="k&lt;x_{1}" display="inline"><semantics><mrow><mi>k</mi><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k&lt;x_{1}</annotation></semantics></math> then <math id="p15.m30" class="ltx_Math" alttext="S\setminus[1;k]" display="inline"><semantics><mrow><mi>S</mi><mo>∖</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>;</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex">S\setminus[1;k]</annotation></semantics></math> contains at least one mininal reduction
with least element <math id="p15.m31" class="ltx_Math" alttext="x_{1}" display="inline"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_{1}</annotation></semantics></math> and so is a reduction because <math id="p15.m32" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is monotonic.
If <math id="p15.m33" class="ltx_Math" alttext="k\geq x_{1}" display="inline"><semantics><mrow><mi>k</mi><mo>≥</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k\geq x_{1}</annotation></semantics></math> then <math id="p15.m34" class="ltx_Math" alttext="S\setminus[1;k]" display="inline"><semantics><mrow><mi>S</mi><mo>∖</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>;</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex">S\setminus[1;k]</annotation></semantics></math> is not a reduction of <math id="p15.m35" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> or a minimal
reduction of <math id="p15.m36" class="ltx_Math" alttext="S\setminus[1;k]" display="inline"><semantics><mrow><mi>S</mi><mo>∖</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>;</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex">S\setminus[1;k]</annotation></semantics></math> would be a minimal reduction of <math id="p15.m37" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> whose
least element is greater than <math id="p15.m38" class="ltx_Math" alttext="x_{1}" display="inline"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_{1}</annotation></semantics></math>. So <math id="p15.m39" class="ltx_Math" alttext="S_{2}=S_{1}\setminus[1;x_{1}-1]" display="inline"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub><mo>=</mo><mrow><msub><mi>S</mi><mn>1</mn></msub><mo>∖</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>;</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">]</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">S_{2}=S_{1}\setminus[1;x_{1}-1]</annotation></semantics></math> is
a reduction of <math id="p15.m40" class="ltx_Math" alttext="S_{1}" display="inline"><semantics><msub><mi>S</mi><mn>1</mn></msub><annotation encoding="application/x-tex">S_{1}</annotation></semantics></math>. The algorithm continues to find
<math id="p15.m41" class="ltx_Math" alttext="x_{2}=\max\{\min(T\setminus\{x_{1}\}):T\text{ is a minimal reduction of }S_{2}%
,\min(T)=x_{1}\}" display="inline"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>min</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mrow><mi>T</mi><mo>∖</mo><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">}</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mrow><mrow><mi>T</mi><mo>⁢</mo><mtext> is a minimal reduction of </mtext><mo>⁢</mo><msub><mi>S</mi><mn>2</mn></msub></mrow><mo>,</mo><mrow><mi>min</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">x_{2}=\max\{\min(T\setminus\{x_{1}\}):T\text{ is a minimal reduction of }S_{2}%
,\min(T)=x_{1}\}</annotation></semantics></math> etc and finally
returns a minimal reduction of <math id="p15.m42" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.
However, it is not clear that this
approach can work if <math id="p15.m43" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is not monotonic while we can hope that Lithium is
still efficient if <math id="p15.m44" class="ltx_Math" alttext="S" display="inline"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is “almost” monotonic.
We remark that when there is only one minimal testcase <math id="p15.m45" class="ltx_Math" alttext="T=[1,M]" display="inline"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>M</mi><mo stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex">T=[1,M]</annotation></semantics></math>, the binary
search approach would require something like
<math id="p15.m46" class="ltx_Math" alttext="\sum_{k=0}^{M-1}\log_{2}(N-k)=M\log_{2}(N)+\sum_{k=0}^{M-1}\log_{2}\left(1-%
\frac{k}{N}\right)\geq M\log_{2}(N)+M\log_{2}\left(1-\frac{M}{N}\right)=M\log_%
{2}(N)+o(M)" display="inline"><semantics><mrow><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>M</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mrow><mi>N</mi><mo>-</mo><mi>k</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>M</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo>(</mo><mrow><mn>1</mn><mo>-</mo><mfrac><mi>k</mi><mi>N</mi></mfrac></mrow><mo>)</mo></mrow></mrow></mrow></mrow><mo>≥</mo><mrow><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo>(</mo><mrow><mn>1</mn><mo>-</mo><mfrac><mi>M</mi><mi>N</mi></mfrac></mrow><mo>)</mo></mrow></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">\sum_{k=0}^{M-1}\log_{2}(N-k)=M\log_{2}(N)+\sum_{k=0}^{M-1}\log_{2}\left(1-%
\frac{k}{N}\right)\geq M\log_{2}(N)+M\log_{2}\left(1-\frac{M}{N}\right)=M\log_%
{2}(N)+o(M)</annotation></semantics></math>. So that would be the worst case of the binary search
approach whereas Lithium handles this case very nicely in
<math id="p15.m47" class="ltx_Math" alttext="\Theta(\log_{2}(N)+M)" display="inline"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>M</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log_{2}(N)+M)</annotation></semantics></math>! In general, if
there is only one minimal testcase <math id="p15.m48" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> of size <math id="p15.m49" class="ltx_Math" alttext="M\leq\frac{N}{2}" display="inline"><semantics><mrow><mi>M</mi><mo>≤</mo><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">M\leq\frac{N}{2}</annotation></semantics></math> then
<math id="p15.m50" class="ltx_Math" alttext="\max(T)" display="inline"><semantics><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\max(T)</annotation></semantics></math> can be anywhere between <math id="p15.m51" class="ltx_Math" alttext="[M,N]" display="inline"><semantics><mrow><mo stretchy="false">[</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[M,N]</annotation></semantics></math> and if <math id="p15.m52" class="ltx_Math" alttext="T" display="inline"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is
placed at random, <math id="p15.m53" class="ltx_Math" alttext="\max(T)\leq\frac{3}{4}N" display="inline"><semantics><mrow><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow></mrow><mo>≤</mo><mrow><mfrac><mn>3</mn><mn>4</mn></mfrac><mo>⁢</mo><mi>N</mi></mrow></mrow><annotation encoding="application/x-tex">\max(T)\leq\frac{3}{4}N</annotation></semantics></math> with probability at least
<math id="p15.m54" class="ltx_Math" alttext="\frac{1}{2}" display="inline"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math>. So the average complexity of the binary search approach in that
case will
be at least <math id="p15.m55" class="ltx_Math" alttext="\frac{1}{2}\sum_{k=0}^{M-1}\log_{2}(\frac{1}{4}N)=\frac{1}{2}M\log_{2}(N)+o(M)" display="inline"><semantics><mrow><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⁢</mo><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>M</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mrow><mfrac><mn>1</mn><mn>4</mn></mfrac><mo>⁢</mo><mi>N</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⁢</mo><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>o</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">\frac{1}{2}\sum_{k=0}^{M-1}\log_{2}(\frac{1}{4}N)=\frac{1}{2}M\log_{2}(N)+o(M)</annotation></semantics></math> which is still not as good as Lithium’s
optimal worst case of <math id="p15.m56" class="ltx_Math" alttext="O(M\log_{2}(\frac{N}{M}))" display="inline"><semantics><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>M</mi><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(M\log_{2}(\frac{N}{M}))</annotation></semantics></math>…</p>
</div>



{% endraw %}
